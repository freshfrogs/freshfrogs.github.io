<!DOCTYPE html>
<html lang="en">
  <head>
      <title>FreshFrogs NFT Collection</title>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel="stylesheet" href="style.css" type="text/css">
      <link rel="shortcut icon" type="image/x-icon" href="https://freshfrogs.github.io/assets/blackWhite.png">
      <script src="https://freshfrogs.github.io/assets/rarityrankings.js"></script>
      <script src="https://freshfrogs.github.io/assets/controller_abi.js"></script>
      <script src="https://freshfrogs.github.io/assets/collection_abi.js"></script>
      <script src="https://freshfrogs.github.io/assets/ethereum-dapp.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.7.0-rc.0/web3.min.js"></script>
      <script src="https://ethereum.factoria.app/f0/token_abi.js"></script>
      <script src="https://unpkg.com/f0js/dist/f0.js"></script>
  </head>
  <body>
    <div class="main_panel">
      <div class="desc_cont">
        <img src="https://freshfrogs.github.io/assets/FLY.gif" class="fly"/>
        <h2>freshfrogs.github.io</h2>
        <p class="title_desc">
          Fresh Frogs NFT is a collection of 4,040 randomly generated frogs that are each unique with thousands of different color combinations, traits, accessories, and more
        </p>
        opensea.io/collection/fresh-frogs
        <br>
        <a class="pointer" href="https://opensea.io/collection/fresh-frogs" target="_blank">Shop on OpenSea ‚õµ</a>
        <hr>
        already own a Frog? <a class="pointer" href="https://freshfrogs.io/the-pond">Stake and Earn Rewards! üê∏</a>
        <br>
        Waiting to Connect Web3 <a class="pointer" href="https://freshfrogs.io/">Connect Wallet üîå</a>
      </div>
    </div>
    <div class="recent_sales" id="recent-sales">
      <p id="recent-sales-status" class="recent_sales_status">Loading recent sales...</p>
    </div>
    <script>
      (function () {
        const API_KEY = 'C71cZZLIIjuEeWwP4s8zut6O3OGJGyoJ';
        const CONTRACT_ADDRESS = '0xBE4Bef8735107db540De269FF82c7dE9ef68C51b';
        const MAX_TRAITS = 3;

        // Optional: set this if you want a mint price fallback in wallet view (in WEI)
        // e.g. const DEFAULT_MINT_PRICE_WEI = "25000000000000000"; // 0.025 ETH
        const DEFAULT_MINT_PRICE_WEI = '';

        const rarityMap = buildRarityMap(window.freshfrogs_rarity_rankings || []);
        const metadataCache = new Map();

        document.addEventListener('DOMContentLoaded', () => {
          const ownerFromPath = getOwnerAddressFromPath();

          if (ownerFromPath) {
            // /0x1234... route ‚Üí show frogs owned by that wallet
            loadWalletFrogs(ownerFromPath);
          } else {
            // normal homepage ‚Üí show recent sales
            loadRecentSales();
          }
        });

        // ------------------------------
        // ROUTING: detect /0x... wallet URLs
        // ------------------------------
        function getOwnerAddressFromPath() {
          const path = window.location.pathname || '/';
          // matches "/0xabc123...def456" or "/0xabc.../" 
          const match = path.match(/^\/(0x[a-fA-F0-9]{40})\/?$/);
          return match ? match[1] : null;
        }

        // ------------------------------
        // RARITY MAP
        // ------------------------------
        function buildRarityMap(rankings) {
          return rankings.reduce((acc, frog) => {
            if (frog && typeof frog.id !== 'undefined') {
              const frogId = Number(frog.id);
              const rankingValue = frog.ranking || frog.rank;
              acc[frogId] = typeof rankingValue !== 'undefined' ? rankingValue : 'N/A';
            }
            return acc;
          }, {});
        }

        // ------------------------------
        // HOMEPAGE: RECENT SALES
        // ------------------------------
        async function loadRecentSales() {
          const container = document.getElementById('recent-sales');
          const statusEl = document.getElementById('recent-sales-status');

          try {
            const sales = await fetchRecentSales();

            if (!sales.length) {
              statusEl.textContent = 'No recent sales found.';
              return;
            }

            if (statusEl) {
              statusEl.remove();
            }

            for (const sale of sales) {
              const card = await buildSaleCard(sale);
              if (card) {
                container.appendChild(card);
              }
            }
          } catch (error) {
            console.error('Unable to load recent sales', error);
            if (statusEl) {
              statusEl.textContent = 'Unable to load recent sales.';
            }
          }
        }

        async function fetchRecentSales() {
          const endpoint = `https://eth-mainnet.g.alchemy.com/nft/v3/${API_KEY}/getNFTSales`;
          const sales = [];
          let pageKey;

          do {
            const params = new URLSearchParams({
              contractAddress: CONTRACT_ADDRESS,
              order: 'desc',
              withMetadata: 'true'
            });

            if (pageKey) {
              params.append('pageKey', pageKey);
            }

            const response = await fetch(`${endpoint}?${params.toString()}`);

            if (!response.ok) {
              throw new Error('Alchemy NFT sales request failed');
            }

            const payload = await response.json();
            sales.push(...(payload.nftSales || []));
            pageKey = payload.pageKey;
          } while (pageKey);

          return sales;
        }

        async function buildSaleCard(sale) {
          const tokenId = normalizeTokenId(
            sale.tokenId ||
              sale.tokenIdDecimal ||
              (sale.nft && sale.nft.tokenId) ||
              (sale.token && sale.token.tokenId)
          );

          if (!tokenId) {
            return null;
          }

          const metadata =
            sale.metadata ||
            sale.tokenMetadata ||
            (await fetchFrogMetadata(tokenId));

          const frogName =
            metadata && metadata.name ? metadata.name : `Frog #${tokenId}`;

          const owner = formatOwnerAddress(
            sale.buyerAddress || sale.to || sale.ownerAddress
          );

          const price = formatPrice(sale);

          const rarityRank =
            typeof rarityMap[tokenId] !== 'undefined'
              ? Number(rarityMap[tokenId])
              : null;

          const rarityTier = rarityRank ? getRarityTier(rarityRank) : null;
          const rarityText = rarityTier ? rarityTier.label : 'Rarity Unknown';
          const rarityClass = rarityTier
            ? `rarity_badge ${rarityTier.className}`
            : 'rarity_badge rarity_unknown';

          const imageUrl = `https://freshfrogs.github.io/frog/${tokenId}.png`;
          const traitsHtml = buildTraitsHtml(metadata);

          const card = document.createElement('div');
          card.className = 'recent_sale_card';
          card.innerHTML = `
            <strong class="sale_card_title">${owner}</strong><strong class="sale_card_price">${price}</strong>
            <div style="clear: both;"></div>
            <div class="frog_img_cont">
              <img src="${imageUrl}" class="recent_sale_img" alt="Frog #${tokenId}" loading="lazy" />
            </div>
            <div class="recent_sale_traits">
              <strong class="sale_card_title">${frogName}</strong><strong class="sale_card_price ${rarityClass}">${rarityText}</strong><br>
              <div class="recent_sale_properties">
                ${traitsHtml}
              </div>
            </div>
          `;

          return card;
        }

        // ------------------------------
        // WALLET VIEW: FROGS OWNED BY ADDRESS
        // ------------------------------
        async function loadWalletFrogs(ownerAddress) {
          const container = document.getElementById('recent-sales');
          const statusEl = document.getElementById('recent-sales-status');

          if (statusEl) {
            statusEl.textContent = `Loading frogs owned by ${formatOwnerAddress(
              ownerAddress
            )}...`;
          }

          try {
            const nfts = await fetchFrogsForOwner(ownerAddress);

            if (!nfts.length) {
              if (statusEl) {
                statusEl.textContent = `No Fresh Frogs found for ${formatOwnerAddress(
                  ownerAddress
                )}.`;
              }
              return;
            }

            if (statusEl) {
              statusEl.remove();
            }

            // Build a card for each frog, using the exact same layout as recent sales
            for (const nft of nfts) {
              const card = await buildOwnedFrogCard(nft, ownerAddress);
              if (card) {
                container.appendChild(card);
              }
            }
          } catch (error) {
            console.error('Unable to load wallet frogs', error);
            if (statusEl) {
              statusEl.textContent = 'Unable to load frogs for this wallet.';
            }
          }
        }

        async function fetchFrogsForOwner(ownerAddress) {
          const endpoint = `https://eth-mainnet.g.alchemy.com/nft/v3/${API_KEY}/getNFTsForOwner`;
          const frogs = [];
          let pageKey;

          do {
            const params = new URLSearchParams({
              owner: ownerAddress,
              'contractAddresses[]': CONTRACT_ADDRESS,
              withMetadata: 'true',
              pageSize: '100'
            });

            if (pageKey) {
              params.append('pageKey', pageKey);
            }

            const response = await fetch(`${endpoint}?${params.toString()}`);
            if (!response.ok) {
              throw new Error('Alchemy getNFTsForOwner request failed');
            }

            const payload = await response.json();
            frogs.push(...(payload.ownedNfts || payload.nfts || []));
            pageKey = payload.pageKey;
          } while (pageKey);

          return frogs;
        }

        async function fetchLastSaleForToken(tokenId) {
          const endpoint = `https://eth-mainnet.g.alchemy.com/nft/v3/${API_KEY}/getNFTSales`;
          const params = new URLSearchParams({
            contractAddress: CONTRACT_ADDRESS,
            tokenId: String(tokenId),
            order: 'desc',
            limit: '1'
          });

          const response = await fetch(`${endpoint}?${params.toString()}`);
          if (!response.ok) {
            console.warn(
              'Alchemy getNFTSales (per-token) request failed for token',
              tokenId
            );
            return null;
          }

          const payload = await response.json();
          const sales = payload.nftSales || [];
          if (!sales.length) {
            return null;
          }
          return sales[0];
        }

        async function buildOwnedFrogCard(nft, ownerAddress) {
          const tokenId = normalizeTokenId(
            nft.tokenId || (nft.id && nft.id.tokenId)
          );
          if (!tokenId) {
            return null;
          }

          // Try to reuse metadata from the NFT call; fall back to the JSON file if needed
          const metadata =
            nft.rawMetadata ||
            nft.metadata ||
            (await fetchFrogMetadata(tokenId));

          const frogName =
            metadata && metadata.name ? metadata.name : `Frog #${tokenId}`;

          const owner = formatOwnerAddress(ownerAddress);

          // Price priority: last sale price ‚Üí mint price (if set) ‚Üí blank
          let price = '';
          try {
            const lastSale = await fetchLastSaleForToken(tokenId);
            if (lastSale) {
              price = formatPrice(lastSale);
            } else if (DEFAULT_MINT_PRICE_WEI) {
              const mintFormatted = formatTokenValue(DEFAULT_MINT_PRICE_WEI, 18);
              price = mintFormatted ? `${mintFormatted} ETH` : '';
            }
          } catch (e) {
            console.warn('Failed to fetch last sale for wallet frog', tokenId, e);
          }

          // If formatPrice returned "Unknown", treat that as blank in wallet view
          if (price === 'Unknown') {
            price = '';
          }

          const rarityRank =
            typeof rarityMap[tokenId] !== 'undefined'
              ? Number(rarityMap[tokenId])
              : null;

          const rarityTier = rarityRank ? getRarityTier(rarityRank) : null;
          const rarityText = rarityTier ? rarityTier.label : 'Rarity Unknown';
          const rarityClass = rarityTier
            ? `rarity_badge ${rarityTier.className}`
            : 'rarity_badge rarity_unknown';

          const imageUrl = `https://freshfrogs.github.io/frog/${tokenId}.png`;
          const traitsHtml = buildTraitsHtml(metadata);

          const card = document.createElement('div');
          card.className = 'recent_sale_card';
          card.innerHTML = `
            <strong class="sale_card_title">${owner}</strong><strong class="sale_card_price">${price}</strong>
            <div style="clear: both;"></div>
            <div class="frog_img_cont">
              <img src="${imageUrl}" class="recent_sale_img" alt="Frog #${tokenId}" loading="lazy" />
            </div>
            <div class="recent_sale_traits">
              <strong class="sale_card_title">${frogName}</strong><strong class="sale_card_price ${rarityClass}">${rarityText}</strong><br>
              <div class="recent_sale_properties">
                ${traitsHtml}
              </div>
            </div>
          `;

          return card;
        }

        // ------------------------------
        // SHARED HELPERS (same as before)
        // ------------------------------
        async function fetchFrogMetadata(tokenId) {
          if (metadataCache.has(tokenId)) {
            return metadataCache.get(tokenId);
          }

          try {
            const response = await fetch(
              `https://freshfrogs.github.io/frog/json/${tokenId}.json`
            );
            if (!response.ok) {
              throw new Error('Metadata fetch failed');
            }
            const data = await response.json();
            metadataCache.set(tokenId, data);
            return data;
          } catch (error) {
            console.warn(`Metadata unavailable for Frog #${tokenId}`, error);
            metadataCache.set(tokenId, null);
            return null;
          }
        }

        function buildTraitsHtml(metadata) {
          const traits = [];
          if (metadata && Array.isArray(metadata.attributes)) {
            const frogTrait = metadata.attributes.find(
              (attr) =>
                attr.trait_type === 'Frog' ||
                attr.trait_type === 'SpecialFrog'
            );
            if (frogTrait) {
              traits.push(`Frog: ${frogTrait.value}`);
            }

            metadata.attributes
              .filter((attr) => attr !== frogTrait)
              .slice(0, MAX_TRAITS - traits.length)
              .forEach((attr) => {
                traits.push(`${attr.trait_type}: ${attr.value}`);
              });
          }

          if (!traits.length) {
            traits.push('Metadata unavailable');
          }

          const traitParagraphs = traits
            .map((trait) => `<p>${trait}</p>`)
            .join('');
          return traitParagraphs;
        }

        function getRarityTier(rank) {
          if (!rank) {
            return null;
          }

          if (rank <= 41) {
            return { label: 'Legendary', className: 'rarity_legendary' };
          }
          if (rank <= 404) {
            return { label: 'Epic', className: 'rarity_epic' };
          }
          if (rank <= 1010) {
            return { label: 'Rare', className: 'rarity_rare' };
          }

          return { label: 'Common', className: 'rarity_common' };
        }

        function normalizeTokenId(value) {
          if (typeof value === 'number') {
            return value;
          }
          if (typeof value === 'string') {
            if (value.startsWith('0x')) {
              return parseInt(value, 16);
            }
            return parseInt(value, 10);
          }
          return null;
        }

        function formatOwnerAddress(address) {
          if (!address) {
            return 'Unknown';
          }
          const normalized = address.startsWith('0x') ? address : `0x${address}`;
          const shortened = `${normalized.slice(0, 6)}..${normalized.slice(-4)}`;
          return shortened.toLowerCase();
        }

        function formatPrice(sale) {
          const sources = [
            sale.price,
            sale.salePrice,
            sale.sellerFee,
            sale.protocolFee
          ];
          const priceSource = sources.find(
            (source) => source && (source.value || source.amount)
          );

          if (!priceSource) {
            return 'Unknown';
          }

          const rawValue = priceSource.value || priceSource.amount;
          const decimals =
            priceSource.decimals ||
            (priceSource.currency && priceSource.currency.decimals) ||
            18;
          const symbol =
            (priceSource.currency && priceSource.currency.symbol) ||
            priceSource.symbol ||
            'ETH';
          const formattedValue = formatTokenValue(rawValue, decimals);

          return formattedValue ? `${formattedValue} ${symbol}` : 'Unknown';
        }

        function formatTokenValue(rawValue, decimals) {
          if (!rawValue && rawValue !== 0) {
            return null;
          }

          try {
            const numericValue = rawValue
              .toString()
              .startsWith('0x')
              ? BigInt(rawValue)
              : BigInt(rawValue);
            const divisor = BigInt(10) ** BigInt(decimals);
            const whole = numericValue / divisor;
            const fraction = numericValue % divisor;
            if (fraction === 0n) {
              return whole.toString();
            }
            const fractionStr = fraction
              .toString()
              .padStart(decimals, '0')
              .slice(0, 3);
            const cleanedFraction = fractionStr.replace(/0+$/, '');
            return cleanedFraction
              ? `${whole.toString()}.${cleanedFraction}`
              : whole.toString();
          } catch (error) {
            const numeric = Number(rawValue) / Math.pow(10, decimals);
            if (!isFinite(numeric)) {
              return null;
            }
            return numeric.toFixed(3);
          }
        }
      })();
    </script>
  </body>
</html>
