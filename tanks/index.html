<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tankers — Card Battle</title>
  <style>
    :root{
      --bg:#0d0f12;
      --panel:#151920;
      --panel2:#10141a;
      --steel:#2a313b;
      --brass:#caa55a;
      --text:#e8edf6;
      --muted:#9aa7bd;
      --good:#65d67a;
      --bad:#ff4b4b;
      --warn:#ffd166;
      --laneGap:12px;
      --radius:14px;
      --shadow: 0 10px 30px rgba(0,0,0,.45);
      --line: rgba(255,255,255,.08);
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 30% -10%, rgba(202,165,90,.12), transparent 55%),
        radial-gradient(1200px 700px at 80% 0%, rgba(101,214,122,.08), transparent 55%),
        linear-gradient(180deg, #0b0d11 0%, #0a0c10 35%, #07090c 100%);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      min-height:100vh;
    }

    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:18px 16px 28px;
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
      margin-bottom:12px;
    }

    .title{
      display:flex;
      align-items:baseline;
      gap:10px;
    }
    .title h1{
      margin:0;
      letter-spacing:.06em;
      font-size:20px;
      text-transform:uppercase;
      color:#f5f7ff;
    }
    .title .sub{
      font-size:12px;
      color:var(--muted);
      letter-spacing:.02em;
    }

    .topbar{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .pill{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      box-shadow: 0 8px 18px rgba(0,0,0,.18);
      font-size:12px;
      color:var(--muted);
      user-select:none;
    }
    .pill strong{color:var(--text); font-weight:700}

    .btn{
      cursor:pointer;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-weight:700;
      letter-spacing:.02em;
      box-shadow: var(--shadow);
    }
    .btn:hover{filter:brightness(1.07)}
    .btn:disabled{
      cursor:not-allowed;
      opacity:.5;
      filter:none;
      box-shadow:none;
    }
    .btn.primary{
      border-color: rgba(202,165,90,.35);
      background: linear-gradient(180deg, rgba(202,165,90,.22), rgba(202,165,90,.08));
    }

    select{
      background: rgba(255,255,255,.06);
      color: var(--text);
      border:1px solid var(--line);
      padding:10px 12px;
      border-radius:12px;
      font-weight:700;
      outline:none;
    }

    .gridShell{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:14px;
      margin-top:12px;
    }

    @media (max-width: 980px){
      .gridShell{grid-template-columns:1fr}
    }

    .board{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:12px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }

    .board::before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(800px 400px at 50% 0%, rgba(202,165,90,.10), transparent 55%),
        radial-gradient(800px 400px at 50% 100%, rgba(101,214,122,.07), transparent 55%);
      pointer-events:none;
      filter: blur(.2px);
    }

    .boardInner{position:relative}

    .rowsLabel{
      display:flex;
      justify-content:space-between;
      gap:10px;
      margin:0 2px 10px;
      font-size:12px;
      color:var(--muted);
      letter-spacing:.06em;
      text-transform:uppercase;
    }

    .hpbar{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-bottom:12px;
    }

    .hpBox{
      flex:1;
      background: rgba(0,0,0,.25);
      border:1px solid var(--line);
      border-radius: 14px;
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .hpBox .who{
      font-weight:900;
      letter-spacing:.06em;
      text-transform:uppercase;
      font-size:12px;
      color: var(--muted);
    }
    .hpBox .hp{
      font-weight:900;
      font-size:16px;
    }
    .hpBox .hp.good{color:var(--good)}
    .hpBox .hp.bad{color:var(--bad)}

    .lanes{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: var(--laneGap);
    }

    .lane{
      border:1px solid var(--line);
      border-radius: 14px;
      padding:10px;
      background: rgba(0,0,0,.16);
      position:relative;
      min-height: 390px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }

    .laneTitle{
      position:absolute;
      top:8px;
      left:10px;
      font-size:11px;
      color:rgba(255,255,255,.35);
      letter-spacing:.1em;
      text-transform:uppercase;
      user-select:none;
    }

    .cell{
      height: 180px;
      border:1px dashed rgba(255,255,255,.12);
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
      margin-top:24px;
    }
    .cell + .cell{ margin-top:10px; }

    .cell.back::after{
      content:"BACK ROW";
      position:absolute;
      bottom:8px;
      right:8px;
      font-size:10px;
      color:rgba(255,255,255,.25);
      letter-spacing:.08em;
    }
    .cell.front::after{
      content:"FRONT ROW";
      position:absolute;
      bottom:8px;
      right:8px;
      font-size:10px;
      color:rgba(255,255,255,.25);
      letter-spacing:.08em;
    }

    .cell.dropOk{
      outline:2px solid rgba(101,214,122,.35);
      box-shadow: 0 0 0 4px rgba(101,214,122,.08);
      border-style:solid;
    }
    .cell.dropNo{
      outline:2px solid rgba(255,75,75,.35);
      box-shadow: 0 0 0 4px rgba(255,75,75,.08);
      border-style:solid;
    }

    .card{
      width: 100%;
      height: 100%;
      border-radius: 10px;
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
      background: rgba(0,0,0,.28);
      position:relative;
      box-shadow: 0 8px 20px rgba(0,0,0,.35);
      user-select:none;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
    }

    .card img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      pointer-events:none;
    }

    .badge{
      position:absolute;
      top:8px;
      left:8px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.18);
      border-radius:999px;
      padding:4px 8px;
      font-size:11px;
      font-weight:900;
      letter-spacing:.06em;
      color:#fff;
      backdrop-filter: blur(6px);
    }
    .badge.cost{ left:auto; right:8px; border-color: rgba(202,165,90,.35); color:#ffe9b5; }
    .badge.hidden{ border-color: rgba(255,255,255,.12); color: rgba(255,255,255,.85); }

    .damageFloat{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:1000;
      font-size:34px;
      color:#fff;
      text-shadow: 0 10px 20px rgba(0,0,0,.65);
      opacity:0;
      transform: translateY(8px);
      pointer-events:none;
    }
    .damageFloat.show{
      opacity:1;
      transform: translateY(0);
      transition: opacity .15s ease, transform .15s ease;
    }

    /* Right panel */
    .side{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:12px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }

    .side h2{
      margin:0 0 10px;
      font-size:13px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color: rgba(255,255,255,.85);
    }

    .hand{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }

    .handCard{
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      overflow:hidden;
      background: rgba(0,0,0,.22);
      cursor:pointer;
      position:relative;
      box-shadow: 0 10px 22px rgba(0,0,0,.25);
    }
    .handCard:hover{filter:brightness(1.06)}
    .handCard.selected{
      outline:2px solid rgba(202,165,90,.45);
      box-shadow: 0 0 0 4px rgba(202,165,90,.12), 0 10px 22px rgba(0,0,0,.25);
    }
    .handCard img{
      width:100%;
      height:150px;
      object-fit:cover;
      display:block;
      pointer-events:none;
    }
    .handMeta{
      padding:8px 8px 10px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:8px;
    }
    .handMeta .nm{
      font-weight:900;
      font-size:12px;
      line-height:1.1;
    }
    .handMeta .tiny{
      font-size:11px;
      color: var(--muted);
      line-height:1.1;
    }
    .handMeta .cost{
      font-weight:1000;
      color:#ffe9b5;
      background: rgba(202,165,90,.15);
      border:1px solid rgba(202,165,90,.30);
      padding:3px 7px;
      border-radius:999px;
      font-size:11px;
      white-space:nowrap;
      margin-top:1px;
    }

    .log{
      margin-top:12px;
      border-top:1px solid var(--line);
      padding-top:10px;
      max-height: 250px;
      overflow:auto;
      font-size:12px;
      color: var(--muted);
    }
    .log p{margin:0 0 6px}
    .log .good{color:rgba(101,214,122,.9)}
    .log .bad{color:rgba(255,75,75,.9)}
    .log .warn{color:rgba(255,209,102,.95)}

    .hint{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--muted);
      font-size:12px;
      line-height:1.35;
    }
    .hint b{color:var(--text)}

    .divider{height:1px; background:var(--line); margin:10px 0}

    .error{
      padding:12px;
      border-radius:12px;
      border:1px solid rgba(255,75,75,.35);
      background: rgba(255,75,75,.10);
      color:#ffd7d7;
      font-weight:700;
      margin-top:12px;
      line-height:1.35;
      white-space:pre-wrap;
    }

    .statusRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .statusRow .muted{color:var(--muted); font-size:12px}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title">
      <h1>Tankers</h1>
      <div class="sub">Inscryption-style lanes • face-down deployment • auto attacks</div>
    </div>

    <div class="topbar">
      <div class="pill"><span>Turn</span> <strong id="turnNum">1</strong></div>
      <div class="pill"><span>Your points</span> <strong id="pPts">1</strong></div>
      <div class="pill"><span>Opponent points</span> <strong id="oPts">1</strong></div>

      <select id="factionPick" title="Pick your faction">
        <option value="germany">Germany</option>
        <option value="allies">Allies</option>
      </select>
      <button class="btn" id="btnNew">New Game</button>
      <button class="btn primary" id="btnEnd" disabled>End Turn</button>
    </div>
  </header>

  <div class="gridShell">
    <div class="board">
      <div class="boardInner">
        <div class="hpbar">
          <div class="hpBox">
            <div class="who">You</div>
            <div class="hp good" id="pHP">20</div>
          </div>
          <div class="hpBox">
            <div class="who">Opponent</div>
            <div class="hp good" id="oHP">20</div>
          </div>
        </div>

        <div class="rowsLabel">
          <div>Opponent side (top lanes)</div>
          <div>Your side (bottom lanes)</div>
        </div>

        <!-- Board lanes: Opponent FRONT/BACK at top, Player FRONT/BACK at bottom -->
        <div class="lanes" id="lanes"></div>

        <div id="err" class="error" style="display:none"></div>
      </div>
    </div>

    <aside class="side">
      <h2>Your Hand</h2>
      <div class="hand" id="hand"></div>

      <div class="statusRow">
        <div class="pill"><span>Selected</span> <strong id="selName">None</strong></div>
        <div class="muted" id="selHint">Click a card, then click an empty BACK ROW slot.</div>
      </div>

      <div class="divider"></div>

      <div class="hint">
        <b>Rules (this version):</b><br>
        • You can only place cards on your <b>BACK ROW</b>.<br>
        • New cards are <b>face-down to the opponent</b> until your next turn.<br>
        • At the start of your next turn, they <b>flip and move to FRONT ROW</b> if the lane is free.<br>
        • On your End Turn, your FRONT ROW tanks <b>auto-attack</b> straight ahead. If no tank blocks the shot, the <b>player takes damage</b>.<br>
        • Each turn your points = the current turn number (reset each turn). Tanks have a tier/cost.
      </div>

      <div class="log" id="log"></div>
    </aside>
  </div>
</div>

<script>
/**
 * DROP-IN NOTES
 * 1) Put your JSON next to this file as: tanks.json
 * 2) Put your generated card back image somewhere, then set CARD_BACK below to its path.
 *    Example: assets/img/card-back.png
 */
const JSON_PATH = "tanks.json";
const CARD_BACK = "assets/img/card-back.png"; // <-- change if needed

// Board setup
const LANES = 4;
const PLAYER_MAX_HP = 20;

// If your JSON doesn't include tier/cost yet, we derive one.
// You can later add: card.tier or card.cost into the JSON and it will be used.
function deriveTier(card){
  if (card.tier) return clampInt(card.tier, 1, 7);
  const s = card.stats || {};
  const score =
    (s.firepower || 0) * 1.2 +
    (s.armor || 0) * 1.0 +
    (s.hp || 0) * 0.5 +
    (s.mobility || 0) * 0.2 +
    (s.accuracy || 0) * 0.2 +
    (s.utility || 0) * 0.1;

  // Tuned so your current cards land ~1–7.
  if (score <= 12) return 1;
  if (score <= 15) return 2;
  if (score <= 18) return 3;
  if (score <= 21) return 4;
  if (score <= 24) return 5;
  if (score <= 27) return 6;
  return 7;
}
function getCost(card){
  if (card.cost) return Math.max(1, Math.floor(card.cost));
  return deriveTier(card);
}
function clampInt(n, a, b){ n = Math.floor(Number(n) || 0); return Math.max(a, Math.min(b, n)); }

const $ = (s)=>document.querySelector(s);
const lanesEl = $("#lanes");
const handEl = $("#hand");
const logEl = $("#log");
const errEl = $("#err");
const btnEnd = $("#btnEnd");
const btnNew = $("#btnNew");
const factionPick = $("#factionPick");

const ui = {
  turn: $("#turnNum"),
  pPts: $("#pPts"),
  oPts: $("#oPts"),
  pHP: $("#pHP"),
  oHP: $("#oHP"),
  selName: $("#selName"),
  selHint: $("#selHint"),
};

let db = null;

let game = null;
// game shape:
// {
//   turn: 1,
//   active: "player" | "opponent",
//   player: { faction, hp, points, deck[], hand[], back[LANES], front[LANES] },
//   opp:    { faction, hp, points, deck[], hand[], back[LANES], front[LANES] },
//   selectedHandIndex: number | null
// }

function log(msg, cls=""){
  const p = document.createElement("p");
  p.textContent = msg;
  if (cls) p.className = cls;
  logEl.prepend(p);
}

function showError(text){
  errEl.style.display = "block";
  errEl.textContent =
`Could not load ${JSON_PATH}.

Fix checklist:
1) Make sure tanks.json is next to this HTML file.
2) Open via a local server (NOT file://). Example:
   - VSCode Live Server
   - python3 -m http.server

Details:
${text}`;
}

function hideError(){ errEl.style.display = "none"; errEl.textContent = ""; }

function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }

async function loadDB(){
  const res = await fetch(JSON_PATH, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
  const data = await res.json();
  if (!data || !Array.isArray(data.factions)) throw new Error(`Expected { "factions": [...] }`);
  return data;
}

function pickFactions(playerFaction){
  const all = db.factions.map(f=>f.faction);
  if (!all.includes(playerFaction)) playerFaction = all[0];

  // Opponent picks first different faction; if only one exists, mirror.
  const oppFaction = all.find(x => x !== playerFaction) || playerFaction;
  return { playerFaction, oppFaction };
}

function makeDeck(factionName){
  const f = db.factions.find(x => x.faction === factionName);
  const cards = (f?.cards || []).map(c => ({
    ...deepCopy(c),
    tier: c.tier ?? deriveTier(c),
    cost: c.cost ?? getCost(c),
  }));
  return shuffle(cards);
}

function drawToHand(side, n=1){
  for (let i=0;i<n;i++){
    if (side.deck.length === 0) return;
    side.hand.push(side.deck.pop());
  }
}

function newGame(){
  hideError();
  logEl.innerHTML = "";

  const { playerFaction, oppFaction } = pickFactions(factionPick.value);

  const player = {
    faction: playerFaction,
    hp: PLAYER_MAX_HP,
    points: 1,
    deck: makeDeck(playerFaction),
    hand: [],
    back: Array(LANES).fill(null),
    front: Array(LANES).fill(null),
  };
  const opp = {
    faction: oppFaction,
    hp: PLAYER_MAX_HP,
    points: 1,
    deck: makeDeck(oppFaction),
    hand: [],
    back: Array(LANES).fill(null),
    front: Array(LANES).fill(null),
  };

  game = {
    turn: 1,
    active: "player",
    player,
    opp,
    selectedHandIndex: null,
  };

  // starting hands
  drawToHand(player, 4);
  drawToHand(opp, 4);

  buildBoardUI();
  renderAll();

  btnEnd.disabled = false;
  log(`New game: You are ${playerFaction.toUpperCase()} vs ${oppFaction.toUpperCase()}.`, "good");
  log(`Turn 1: You have 1 point. Play a Tier 1 tank on your BACK ROW.`, "warn");
}

function buildBoardUI(){
  lanesEl.innerHTML = "";
  for (let lane=0; lane<LANES; lane++){
    const laneEl = document.createElement("div");
    laneEl.className = "lane";
    laneEl.dataset.lane = lane;
    laneEl.innerHTML = `
      <div class="laneTitle">Lane ${lane+1}</div>

      <!-- Opponent side (top) -->
      <div class="cell front" data-owner="opponent" data-row="front" data-lane="${lane}"></div>
      <div class="cell back"  data-owner="opponent" data-row="back"  data-lane="${lane}"></div>

      <!-- Player side (bottom) -->
      <div class="cell front" data-owner="player" data-row="front" data-lane="${lane}"></div>
      <div class="cell back"  data-owner="player" data-row="back"  data-lane="${lane}"></div>
    `;
    lanesEl.appendChild(laneEl);
  }

  // Click placement handling
  lanesEl.addEventListener("click", (e)=>{
    const cell = e.target.closest(".cell");
    if (!cell) return;

    const owner = cell.dataset.owner;
    const row = cell.dataset.row;
    const lane = Number(cell.dataset.lane);

    // Only player can place, only on player back row, only during player turn
    if (!game || game.active !== "player") return;
    if (owner !== "player" || row !== "back") {
      flashCell(cell, false);
      return;
    }

    placeSelectedIntoLane(lane);
  });
}

function flashCell(cell, ok){
  cell.classList.remove("dropOk","dropNo");
  cell.classList.add(ok ? "dropOk" : "dropNo");
  setTimeout(()=>cell.classList.remove("dropOk","dropNo"), 260);
}

function selectHand(idx){
  game.selectedHandIndex = idx;
  renderHand();
}

function clearSelection(){
  game.selectedHandIndex = null;
  renderHand();
}

function placeSelectedIntoLane(lane){
  const idx = game.selectedHandIndex;
  if (idx === null || idx === undefined) {
    ui.selHint.textContent = "Select a card first.";
    return;
  }

  const card = game.player.hand[idx];
  if (!card) return;

  const cost = getCost(card);
  if (cost > game.player.points){
    ui.selHint.textContent = `Not enough points. Need ${cost}, you have ${game.player.points}.`;
    flashCell(document.querySelector(`.cell[data-owner="player"][data-row="back"][data-lane="${lane}"]`), false);
    return;
  }

  if (game.player.back[lane] !== null){
    ui.selHint.textContent = "That BACK ROW slot is occupied.";
    flashCell(document.querySelector(`.cell[data-owner="player"][data-row="back"][data-lane="${lane}"]`), false);
    return;
  }

  // Place it
  game.player.points -= cost;
  game.player.hand.splice(idx,1);
  game.selectedHandIndex = null;

  const state = makeCardState(card, "player", /*hiddenToOpponent*/ true);
  game.player.back[lane] = state;

  log(`You deployed ${card.name} face-down to the opponent (Lane ${lane+1}).`, "good");
  ui.selHint.textContent = "Placed. End Turn to attack (your front row), then opponent plays.";

  renderAll();
}

function makeCardState(card, owner, hiddenToOpponent){
  return {
    owner,
    data: card,
    hp: card.stats?.hp ?? 10,
    hiddenToOpponent: !!hiddenToOpponent, // face-down to enemy while in back row
  };
}

function visibleImageFor(cardState, viewer){
  // viewer: "player" perspective (what you see on screen)
  const isOwner = (cardState.owner === viewer);
  const isHidden = cardState.hiddenToOpponent && !isOwner;
  return isHidden ? CARD_BACK : cardState.data.image;
}

function renderAll(){
  if (!game) return;

  // top HUD
  ui.turn.textContent = String(game.turn);
  ui.pPts.textContent = String(game.player.points);
  ui.oPts.textContent = String(game.opp.points);

  ui.pHP.textContent = String(game.player.hp);
  ui.oHP.textContent = String(game.opp.hp);

  ui.pHP.className = "hp " + (game.player.hp >= 11 ? "good" : "bad");
  ui.oHP.className = "hp " + (game.opp.hp >= 11 ? "good" : "bad");

  renderBoard();
  renderHand();

  const sel = (game.selectedHandIndex !== null) ? game.player.hand[game.selectedHandIndex] : null;
  ui.selName.textContent = sel ? sel.name : "None";
}

function renderBoard(){
  // For each cell, render card if present
  const cells = lanesEl.querySelectorAll(".cell");
  cells.forEach(cell=>{
    const owner = cell.dataset.owner;
    const row = cell.dataset.row;
    const lane = Number(cell.dataset.lane);

    const side = owner === "player" ? game.player : game.opp;
    const cardState = (row === "front") ? side.front[lane] : side.back[lane];

    cell.innerHTML = "";

    if (!cardState) return;

    const cardEl = document.createElement("div");
    cardEl.className = "card";
    const img = document.createElement("img");
    img.src = visibleImageFor(cardState, "player");
    img.alt = cardState.data.name;

    cardEl.appendChild(img);

    const cost = getCost(cardState.data);
    const tier = deriveTier(cardState.data);

    // If hidden to opponent (and it's opponent card), show "HIDDEN" badge.
    // For player cards in back row, you can see them, but opponent can't — so no "hidden" badge needed visually.
    if (cardState.hiddenToOpponent && cardState.owner !== "player"){
      const b = document.createElement("div");
      b.className = "badge hidden";
      b.textContent = "FACE DOWN";
      cardEl.appendChild(b);
    }

    const bc = document.createElement("div");
    bc.className = "badge cost";
    bc.textContent = `T${tier} • ${cost}`;
    cardEl.appendChild(bc);

    const bhp = document.createElement("div");
    bhp.className = "badge";
    bhp.textContent = `HP ${cardState.hp}`;
    cardEl.appendChild(bhp);

    const dmg = document.createElement("div");
    dmg.className = "damageFloat";
    dmg.textContent = "";
    cardEl.appendChild(dmg);

    cell.appendChild(cardEl);
  });
}

function renderHand(){
  handEl.innerHTML = "";
  if (!game) return;

  const hand = game.player.hand;
  if (hand.length === 0){
    const empty = document.createElement("div");
    empty.style.gridColumn = "1 / -1";
    empty.className = "hint";
    empty.innerHTML = `<b>No cards in hand.</b><br>End turns to draw more.`;
    handEl.appendChild(empty);
  }

  hand.forEach((card, idx)=>{
    const el = document.createElement("div");
    el.className = "handCard" + (game.selectedHandIndex === idx ? " selected" : "");
    el.addEventListener("click", ()=>{
      if (!game || game.active !== "player") return;
      if (game.selectedHandIndex === idx) clearSelection();
      else selectHand(idx);
    });

    const cost = getCost(card);
    const tier = deriveTier(card);

    el.innerHTML = `
      <img src="${card.image}" alt="${card.name}" draggable="false">
      <div class="handMeta">
        <div>
          <div class="nm">${card.name}</div>
          <div class="tiny">T${tier} • FP ${card.stats.firepower} • AR ${card.stats.armor}</div>
        </div>
        <div class="cost">${cost}</div>
      </div>
    `;

    // Disable look if can't afford
    if (cost > game.player.points || game.active !== "player"){
      el.style.opacity = "0.6";
    }

    handEl.appendChild(el);
  });

  if (game.active !== "player"){
    ui.selHint.textContent = "Opponent is taking their turn…";
  } else {
    ui.selHint.textContent = "Click a card, then click an empty BACK ROW slot.";
  }
}

/* ===========================
   TURN / PHASE LOGIC
   =========================== */

function startTurn(sideName){
  game.active = sideName;

  // Points reset to turn number (your rule)
  const side = sideName === "player" ? game.player : game.opp;
  side.points = game.turn;

  // Promote back -> front if lane free, and reveal (hiddenToOpponent false)
  promoteBackRow(sideName);

  // Draw 1 at start of turn
  drawToHand(side, 1);

  if (sideName === "player"){
    log(`Your turn ${game.turn}. Points: ${side.points}.`, "warn");
  } else {
    log(`Opponent turn ${game.turn}.`, "warn");
  }

  renderAll();
}

function promoteBackRow(sideName){
  const side = sideName === "player" ? game.player : game.opp;

  for (let lane=0; lane<LANES; lane++){
    const backCard = side.back[lane];
    if (!backCard) continue;

    // Only promote if front is empty
    if (side.front[lane] === null){
      side.front[lane] = backCard;
      side.back[lane] = null;

      // Reveal to opponent once it hits the front
      backCard.hiddenToOpponent = false;

      if (sideName === "player"){
        log(`${backCard.data.name} flips to FRONT ROW (Lane ${lane+1}) and is now revealed.`, "good");
      } else {
        log(`Opponent tank flips to FRONT ROW (Lane ${lane+1}).`, "bad");
      }
    }
  }
}

function resolveAttacks(attackerSideName){
  const A = attackerSideName === "player" ? game.player : game.opp;
  const D = attackerSideName === "player" ? game.opp : game.player;

  for (let lane=0; lane<LANES; lane++){
    const atk = A.front[lane];
    if (!atk) continue;

    const fp = atk.data.stats?.firepower ?? 0;
    if (fp <= 0) continue;

    const def = D.front[lane];
    if (def){
      // Basic damage model for now:
      // damage = max(1, firepower - floor(armor/2)) to keep armor meaningful but not insane.
      const armor = def.data.stats?.armor ?? 0;
      const dmg = Math.max(1, fp - Math.floor(armor/2));
      def.hp -= dmg;

      floatDamage(attackerSideName === "player" ? "opponent" : "player", "front", lane, `-${dmg}`);

      log(`${atk.data.name} hits ${def.data.name} (Lane ${lane+1}) for ${dmg}.`, attackerSideName === "player" ? "good" : "bad");

      if (def.hp <= 0){
        log(`${def.data.name} is destroyed!`, "warn");
        D.front[lane] = null;
      }
    } else {
      // Hit player directly
      D.hp -= fp;
      log(`${atk.data.name} fires down Lane ${lane+1} and hits the ${attackerSideName === "player" ? "opponent" : "player"} for ${fp}.`, attackerSideName === "player" ? "good" : "bad");
      if (attackerSideName === "player"){
        ui.oHP.classList.add("bad");
      } else {
        ui.pHP.classList.add("bad");
      }
    }

    if (D.hp <= 0) break;
  }

  renderAll();
}

function floatDamage(owner, row, lane, text){
  const cell = document.querySelector(`.cell[data-owner="${owner}"][data-row="${row}"][data-lane="${lane}"]`);
  if (!cell) return;
  const dmg = cell.querySelector(".damageFloat");
  if (!dmg) return;
  dmg.textContent = text;
  dmg.classList.add("show");
  setTimeout(()=>dmg.classList.remove("show"), 420);
}

function checkGameOver(){
  if (game.player.hp <= 0){
    log("You lose.", "bad");
    btnEnd.disabled = true;
    return true;
  }
  if (game.opp.hp <= 0){
    log("You win!", "good");
    btnEnd.disabled = true;
    return true;
  }
  return false;
}

/* ===========================
   OPPONENT AI
   =========================== */
function opponentPlay(){
  const opp = game.opp;

  // Simple AI: spend as many points as possible, highest cost first
  // It places only in its BACK ROW
  const lanes = [...Array(LANES).keys()];
  shuffle(lanes);

  // Sort hand by cost descending
  const hand = opp.hand.slice().sort((a,b)=>getCost(b)-getCost(a));

  for (const card of hand){
    const cost = getCost(card);
    if (cost > opp.points) continue;

    const lane = lanes.find(L => opp.back[L] === null);
    if (lane === undefined) break;

    // remove from actual hand
    const idx = opp.hand.findIndex(x => x.id === card.id && x.name === card.name);
    if (idx >= 0) opp.hand.splice(idx,1);

    opp.points -= cost;
    opp.back[lane] = makeCardState(card, "opponent", /*hiddenToOpponent*/ true);

    log(`Opponent deploys a tank (Lane ${lane+1}) face-down.`, "bad");
  }

  renderAll();
}

/* ===========================
   TURN BUTTON
   =========================== */
btnEnd.addEventListener("click", async ()=>{
  if (!game || game.active !== "player") return;

  // Player attack phase on End Turn
  resolveAttacks("player");
  if (checkGameOver()) return;

  // Opponent turn
  startTurn("opponent");

  // Opponent plays
  opponentPlay();

  // Opponent attacks at end of their turn (auto)
  resolveAttacks("opponent");
  if (checkGameOver()) return;

  // Next turn
  game.turn += 1;
  startTurn("player");
});

/* ===========================
   NEW GAME / INIT
   =========================== */
btnNew.addEventListener("click", newGame);

(async function init(){
  // preload card back so it doesn't flicker
  const img = new Image();
  img.src = CARD_BACK;

  try{
    db = await loadDB();
    btnEnd.disabled = false;
    log(`Loaded ${db.factions.length} faction(s) from ${JSON_PATH}.`, "good");
    newGame();
  }catch(e){
    showError(String(e && e.message ? e.message : e));
  }
})();
</script>
</body>
</html>
