<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tankers ‚Äî Inscryption-style</title>
  <style>
    :root{
      --bg:#0c0f14;
      --text:#e7edf7;
      --muted:#9bb0cc;
      --line:rgba(255,255,255,.10);
      --accent:#f7c34a;
      --good:#62ff9b;
      --bad:#ff5b5b;
      --radius:14px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 700px at 15% 0%, rgba(247,195,74,.12), transparent 55%),
                  radial-gradient(1000px 600px at 90% 20%, rgba(80,180,255,.10), transparent 55%),
                  var(--bg);
      color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:10;
      backdrop-filter: blur(10px);
      background: rgba(12,15,20,.70);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1200px;margin:0 auto;padding:16px;}
    .top{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap;}
    .brand{display:flex;align-items:center;gap:10px;font-weight:900;letter-spacing:.4px;}
    .badge{font-size:12px;color:#111;background:var(--accent);padding:4px 8px;border-radius:999px;font-weight:900;}
    .btn{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color:var(--text);
      padding:9px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:900;
    }
    .btn:hover{border-color: rgba(247,195,74,.45)}
    .btn:disabled{opacity:.45; cursor:not-allowed}
    select{
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color:var(--text);
      padding:9px 12px;
      border-radius:12px;
      font-weight:800;
      outline:none;
    }

    .layout{
      display:grid;
      grid-template-columns: 1fr 340px;
      gap:14px;
    }
    @media (max-width: 980px){ .layout{grid-template-columns:1fr;} }

    .setup{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      padding:14px;
    }
    .setup h2{margin:0 0 8px 0;font-size:18px;}
    .setup p{margin:0 0 14px 0;color:var(--muted);font-size:13px;line-height:1.35;}
    .setupRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .setupCol{display:flex;flex-direction:column;gap:6px;min-width:220px}
    .setupCol label{color:var(--muted);font-size:12px;font-weight:900;letter-spacing:.08em;text-transform:uppercase}

    .board{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      overflow:hidden;
    }
    .boardTop{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:10px;
      flex-wrap:wrap;
    }
    .boardTop .title{font-weight:900;letter-spacing:.3px;}
    .boardTop .sub{color:var(--muted);font-size:12px;line-height:1.2;}

    .grid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      padding:12px;
    }
    .cell{
      aspect-ratio: 3/4;
      border-radius:14px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      position:relative;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
    }
    .cell.empty::after{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(400px 240px at 50% 20%, rgba(255,255,255,.06), transparent 55%);
      opacity:.9;
      pointer-events:none;
    }
    .cell.hilite{border-color: rgba(247,195,74,.85); box-shadow: 0 0 0 3px rgba(247,195,74,.14);}

    .unitImg{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      pointer-events:none;
    }
    .cardBack{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        radial-gradient(900px 500px at 30% 20%, rgba(247,195,74,.18), transparent 60%),
        radial-gradient(700px 420px at 80% 70%, rgba(80,180,255,.14), transparent 60%),
        rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      color: rgba(231,237,247,.75);
      font-weight:1000;
      letter-spacing:.18em;
      text-transform:uppercase;
      pointer-events:none;
    }
    .hpTag{
      position:absolute;
      left:8px; top:8px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      padding:4px 8px;
      font-size:12px;
      font-weight:900;
      display:flex;
      gap:6px;
      align-items:center;
      pointer-events:none;
    }
    .hpTag .dot{
      width:8px;height:8px;border-radius:999px;background: var(--good);
      box-shadow: 0 0 0 3px rgba(98,255,155,.12);
    }
    .hpTag.ai .dot{background: var(--bad); box-shadow: 0 0 0 3px rgba(255,91,91,.12);}
    .sideMark{
      position:absolute;
      right:8px; top:8px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      padding:4px 8px;
      font-size:11px;
      color:var(--muted);
      font-weight:900;
      letter-spacing:.08em;
      text-transform:uppercase;
      pointer-events:none;
    }
    .tagBottom{
      position:absolute;
      left:8px; bottom:8px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      padding:4px 8px;
      font-size:11px;
      color:var(--muted);
      font-weight:900;
      pointer-events:none;
    }

    .hands{
      border-top:1px solid var(--line);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .handTitle{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      color:var(--muted);
      font-size:12px;
      font-weight:900;
      letter-spacing:.08em;
      text-transform:uppercase;
    }
    .handRow{
      display:grid;
      grid-template-columns: repeat(5, minmax(0,1fr));
      gap:10px;
    }
    @media (max-width:700px){ .handRow{grid-template-columns: repeat(4, 1fr);} }
    @media (max-width:520px){ .handRow{grid-template-columns: repeat(3, 1fr);} }

    .handCard{
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      background: rgba(0,0,0,.18);
      cursor:pointer;
      position:relative;
      aspect-ratio: 2/3;
      transition: transform .08s ease, border-color .08s ease;
    }
    .handCard:hover{transform: translateY(-2px); border-color: rgba(247,195,74,.45);}
    .handCard.selected{
      border-color: rgba(247,195,74,.85);
      box-shadow: 0 0 0 3px rgba(247,195,74,.16);
    }
    .handCard img{width:100%;height:100%;object-fit:cover;display:block; pointer-events:none;}
    .handCard .mini{
      position:absolute;
      left:8px; bottom:8px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      padding:4px 8px;
      font-size:12px;
      font-weight:900;
      display:flex;
      gap:8px;
      align-items:center;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      font-weight:900;
      font-size:12px;
    }
    .pill .dot{
      width:8px;height:8px;border-radius:999px;background: var(--accent);
      box-shadow: 0 0 0 3px rgba(247,195,74,.12);
    }

    .side{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height: 560px;
    }
    .sideTop{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:10px;
      flex-wrap:wrap;
    }
    .sideTop .title{font-weight:900;letter-spacing:.3px;}
    .sideTop .sub{color:var(--muted);font-size:12px;}
    .panel{padding:12px; display:flex; flex-direction:column; gap:10px;}
    .kv{
      display:flex; justify-content:space-between; gap:10px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius:12px;
      padding:10px 10px;
      font-size:13px;
    }
    .kv span{color:var(--muted);font-weight:900}
    .kv b{font-weight:900}

    .log{
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius:12px;
      padding:10px;
      height: 330px;
      overflow:auto;
      font-size:12px;
      line-height:1.35;
      color: rgba(231,237,247,.92);
    }
    .log .muted{color: var(--muted)}
    .note{color:var(--muted);font-size:12px;line-height:1.35;}
    .hidden{display:none!important}
    code{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="top">
      <div class="brand">
        <span style="font-size:18px;">ü™ñ</span>
        <span>Tankers</span>
        <span class="badge">Inscryption-style</span>
      </div>
      <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
        <button class="btn hidden" id="btnRestart">Restart</button>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="wrap">
    <div id="setup" class="setup">
      <h2>Start Game</h2>
      <p>
        Each round you get points equal to the round number (1, 2, 3...). Deploy cost = <b>Tier</b> from <code>tanks.json</code>.
        Cards are played <b>face-down</b>, then on the owner's next turn they <b>advance 1 row</b> and become <b>revealed</b>.
        Attacks happen automatically at the <b>end</b> of the active player's turn.
      </p>
      <div class="setupRow">
        <div class="setupCol">
          <label for="playerFaction">Your faction</label>
          <select id="playerFaction"></select>
        </div>
        <div class="setupCol">
          <label for="aiFaction">Opponent faction</label>
          <select id="aiFaction"></select>
        </div>
        <div class="setupCol" style="min-width:auto;">
          <label>&nbsp;</label>
          <button class="btn" id="btnStart">Start</button>
        </div>
      </div>
      <div class="note" style="margin-top:10px;">
        If images don‚Äôt load, run: <code>python3 -m http.server 8080</code> then open <code>http://localhost:8080/tankers.html</code>.
      </div>
    </div>

    <div id="game" class="layout hidden">
      <div class="board">
        <div class="boardTop">
          <div>
            <div class="title">Battlefield (4x4)</div>
            <div class="sub" id="turnText">‚Äî</div>
          </div>
          <div class="sub" id="statusText">‚Äî</div>
        </div>

        <div class="grid" id="grid"></div>

        <div class="hands">
          <div class="handTitle">
            <div>Your hand (click a card, then click a column to play)</div>
            <div id="playerCount" class="muted"></div>
          </div>
          <div class="handRow" id="playerHand"></div>

          <div class="handTitle">
            <div>Opponent info (hand hidden)</div>
            <div id="aiCount" class="muted"></div>
          </div>
        </div>
      </div>

      <div class="side">
        <div class="sideTop">
          <div>
            <div class="title">Turn</div>
            <div class="sub" id="sideSub">‚Äî</div>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
            <span class="pill"><span class="dot"></span><span>Points:</span><b id="apText">0</b></span>
            <button class="btn" id="btnEndTurn">End Turn</button>
          </div>
        </div>

        <div class="panel">
          <div class="kv"><span>You</span><b id="youLabel">‚Äî</b></div>
          <div class="kv"><span>Opponent</span><b id="aiLabel">‚Äî</b></div>
          <div class="kv"><span>Selected card</span><b id="selLabel">None</b></div>

          <div class="note">
            <b>Play:</b> select a hand card ‚Üí click any tile in a column to play there (drops to your back row in that column).<br>
            <b>Reveal:</b> next time that tank gets a turn, it advances 1 row and flips face-up.<br>
            <b>Auto-attack:</b> end of turn, revealed tanks attack the first enemy in the same column within <b>Accuracy</b> range.
          </div>

          <div class="log" id="log"></div>
        </div>
      </div>
    </div>
  </div>
</main>

<script>
  // ================== CONFIG ==================
  const DATA_URL = "tanks.json";
  const HAND_SIZE = 5;
  const COPIES_PER_CARD = 2;

  // ================== STATE ==================
  let factions = [];
  let player = null;
  let ai = null;

  // board rows 0..3 top->bottom, cols 0..3 left->right
  // cell null or unit { uid, side, card, hp, revealed, justDeployedRound }
  let board = null;
  let UID = 0;

  let round = 1;
  let activeSide = "player"; // "player" | "ai"
  let ap = 0;

  let selectedHandIndex = null;

  // ================== DOM ==================
  const elSetup = document.getElementById("setup");
  const elGame = document.getElementById("game");
  const playerFactionSel = document.getElementById("playerFaction");
  const aiFactionSel = document.getElementById("aiFaction");
  const btnStart = document.getElementById("btnStart");
  const btnRestart = document.getElementById("btnRestart");

  const gridEl = document.getElementById("grid");
  const logEl = document.getElementById("log");
  const turnText = document.getElementById("turnText");
  const statusText = document.getElementById("statusText");

  const playerHandEl = document.getElementById("playerHand");
  const playerCountEl = document.getElementById("playerCount");
  const aiCountEl = document.getElementById("aiCount");

  const youLabel = document.getElementById("youLabel");
  const aiLabel = document.getElementById("aiLabel");
  const selLabel = document.getElementById("selLabel");
  const sideSub = document.getElementById("sideSub");
  const apText = document.getElementById("apText");

  const btnEndTurn = document.getElementById("btnEndTurn");

  // ================== HELPERS ==================
  const titleCase = (s) => (s || "").replace(/[_-]/g," ").replace(/\b\w/g, c => c.toUpperCase()).trim();

  function escapeHtml(s){
    return String(s ?? "").replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  function log(line, muted=false){
    const div = document.createElement("div");
    div.innerHTML = muted ? `<span class="muted">${escapeHtml(line)}</span>` : escapeHtml(line);
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
  }

  function shuffle(arr){
    const a = [...arr];
    for (let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }

  function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }

  function makeDeck(cards){
    const deck = [];
    for (const c of cards){
      for (let i=0;i<COPIES_PER_CARD;i++) deck.push(deepCopy(c));
    }
    return shuffle(deck);
  }

  function drawToHand(sideObj){
    while (sideObj.hand.length < HAND_SIZE && sideObj.deck.length){
      sideObj.hand.push(sideObj.deck.pop());
    }
  }

  function countBoardUnits(side){
    let n=0;
    for (let r=0;r<4;r++) for (let c=0;c<4;c++){
      const u = board[r][c];
      if (u && u.side === side) n++;
    }
    return n;
  }

  // ================== TIER / COST (FROM JSON) ==================
  function clampTier(t){
    if (!Number.isFinite(t)) return 1;
    return Math.max(1, Math.min(9, t));
  }

  function deriveTier(card){
    const raw = Number(card?.tier);
    if (!Number.isFinite(raw)){
      console.warn("Missing tier on card:", card?.id, card?.name);
      return 1;
    }
    return clampTier(raw);
  }

  function costToDeploy(card){
    return deriveTier(card); // Tier = cost
  }

  // ================== DEPLOY (face-down) ==================
  function findDropRow(side, col){
    if (side === "player"){
      for (let r=3;r>=0;r--) if (!board[r][col]) return r;
    } else {
      for (let r=0;r<4;r++) if (!board[r][col]) return r;
    }
    return null;
  }

  function deployFromHand(side, handIndex, col){
    const who = side === "player" ? player : ai;
    const row = findDropRow(side, col);
    if (row === null) return { ok:false, reason:"Column full." };

    const card = who.hand[handIndex];
    const cost = costToDeploy(card);
    if (ap < cost) return { ok:false, reason:`Not enough points (need ${cost}).` };

    ap -= cost;
    const played = who.hand.splice(handIndex, 1)[0];

    board[row][col] = {
      uid: ++UID,
      side,
      card: played,
      hp: Number(played.stats.hp ?? 1),
      revealed: false,              // face-down initially
      justDeployedRound: round      // flip/move next owner turn
    };

    log(`${titleCase(side)} plays a card face-down in column ${col+1} (cost ${cost}).`);
    return { ok:true };
  }

  // ================== AUTO ADVANCE + REVEAL ==================
  function advanceAndReveal(side){
    // Owner's next turn: units attempt to move 1 tile forward if empty; then reveal
    // Player moves UP (r-1). AI moves DOWN (r+1).
    const dir = (side === "player") ? -1 : +1;

    // Move order matters to avoid leapfrogging. Move front-to-back in movement direction.
    const rows = side === "player" ? [0,1,2,3] : [3,2,1,0];

    let movedCount = 0;
    let revealedCount = 0;

    for (const r of rows){
      for (let c=0;c<4;c++){
        const u = board[r][c];
        if (!u || u.side !== side) continue;

        // If it was just deployed on a previous owner turn, it becomes eligible to reveal now
        const shouldRevealThisTurn = (u.justDeployedRound < round) || (u.justDeployedRound === round && side !== activeSide);
        // We'll reveal on owner's turn start regardless (but only if it's been on board at least 1 full turn)
        const eligibleToFlip = (u.justDeployedRound < round);

        // Attempt advance
        const nr = r + dir;
        if (nr >= 0 && nr <= 3 && !board[nr][c]){
          board[nr][c] = u;
          board[r][c] = null;
          movedCount++;
        }

        // Reveal if eligible (owner's next turn)
        // We reveal at the start of owner's turn if it was played on a prior round OR prior turn in same round.
        // Simple rule: if it existed before this turn started (i.e. justDeployedRound < round OR it was played earlier this round by owner).
        // For a clean ‚Äúnext turn‚Äù feel: reveal if it was played on any earlier turn (tracked via justDeployedRound < round OR marked lastTurnSide).
        // We‚Äôll do strict: reveal if it was played on a previous turn (we‚Äôll track via justDeployedRound < round OR u.revealed already).
        if (!u.revealed){
          // Strict next-owner-turn reveal:
          // if it was deployed earlier (any time before this exact turn start), flip now.
          // We treat "deployedRound < round" as definitely earlier; for same round, it flips next turn as well (handled by side turn sequencing below).
          if (eligibleToFlip){
            u.revealed = true;
            revealedCount++;
          }
        }
      }
    }

    if (movedCount) log(`${titleCase(side)} advance: ${movedCount} unit(s) moved forward.`, true);
    if (revealedCount) log(`${titleCase(side)} reveal: ${revealedCount} unit(s) flipped face-up.`, true);
  }

  // ================== AUTO ATTACK (end of turn) ==================
  function firstTargetInColumn(attackerPos){
    const attacker = board[attackerPos.r][attackerPos.c];
    if (!attacker) return null;

    const dir = attacker.side === "player" ? -1 : +1;
    const range = Math.max(1, Number(attacker.card.stats.accuracy ?? 1));

    for (let step=1; step<=range; step++){
      const rr = attackerPos.r + dir*step;
      if (rr < 0 || rr > 3) break;
      const t = board[rr][attackerPos.c];
      if (t && t.side !== attacker.side) return { r: rr, c: attackerPos.c };
    }
    return null;
  }

  function computeDamage(attackerUnit, targetUnit){
    // Simple frontal math. You can tweak later.
    const firepower = Number(attackerUnit.card.stats.firepower ?? 1);
    const armor = Number(targetUnit.card.stats.armor ?? 0);
    const dmg = Math.max(1, firepower - Math.floor(armor / 2));
    return dmg;
  }

  function autoAttack(side){
    // Only revealed units attack (feels like ‚Äúflipped / active‚Äù).
    // Resolve from front line outward so it feels consistent.
    const rows = side === "player" ? [0,1,2,3] : [3,2,1,0];
    let attacks = 0;

    for (const r of rows){
      for (let c=0;c<4;c++){
        const u = board[r][c];
        if (!u || u.side !== side) continue;
        if (!u.revealed) continue;

        const targetPos = firstTargetInColumn({r,c});
        if (!targetPos) continue;

        const target = board[targetPos.r][targetPos.c];
        if (!target) continue;

        const dmg = computeDamage(u, target);
        target.hp -= dmg;
        attacks++;

        const sideA = side === "player" ? "You" : "AI";
        const sideT = target.side === "player" ? "You" : "AI";

        log(`${sideA} ${u.card.name} fires down lane ${c+1} for ${dmg} damage ‚Üí ${sideT} (${target.revealed ? target.card.name : "Face-down unit"})`);

        if (target.hp <= 0){
          log(`${sideT} unit in lane ${c+1} is destroyed!`);
          board[targetPos.r][targetPos.c] = null;
        }
      }
    }

    if (!attacks) log(`${titleCase(side)} auto-attack: no shots fired.`, true);
  }

  // ================== TURN FLOW ==================
  function beginTurn(side){
    activeSide = side;

    // round points (shared rule)
    ap = round;

    // draw at start of turn (Inscryption-ish)
    const who = (side === "player") ? player : ai;
    drawToHand(who);

    // advance + reveal at start of owner's turn
    advanceAndReveal(side);

    selectedHandIndex = null;
    selLabel.textContent = "None";

    renderAll();
    log(`‚Äî Round ${round}: ${side === "player" ? "Your" : "AI"} turn (${ap} points).`, true);
  }

  function endTurn(){
    if (checkEnd()) return;

    // end of turn auto-attacks
    autoAttack(activeSide);
    renderAll();

    if (checkEnd()) return;

    // swap turn
    if (activeSide === "player"){
      beginTurn("ai");
      window.setTimeout(aiTurn, 450);
    } else {
      round += 1;
      beginTurn("player");
    }
  }

  function checkEnd(){
    const pUnits = countBoardUnits("player");
    const aUnits = countBoardUnits("ai");

    const pHas = pUnits > 0 || player.hand.length > 0 || player.deck.length > 0;
    const aHas = aUnits > 0 || ai.hand.length > 0 || ai.deck.length > 0;

    if (!pHas && !aHas){ gameOver("Draw ‚Äî both sides ran out."); return true; }
    if (!aHas){ gameOver("You win!"); return true; }
    if (!pHas){ gameOver("AI wins!"); return true; }
    return false;
  }

  function gameOver(msg){
    statusText.textContent = msg;
    turnText.textContent = "Game over.";
    btnRestart.classList.remove("hidden");
    btnEndTurn.disabled = true;
    log(msg);
    renderAll();
  }

  // ================== AI (simple) ==================
  function aiTurn(){
    if (activeSide !== "ai") return;

    // Deploy as much as possible, cheapest-first
    let safety = 50;
    while (ap > 0 && ai.hand.length > 0 && safety-- > 0){
      const affordable = ai.hand
        .map((card, idx) => ({card, idx, cost: costToDeploy(card)}))
        .filter(x => x.cost <= ap);

      if (!affordable.length) break;
      affordable.sort((a,b)=>a.cost-b.cost);

      const choice = affordable[0];
      const cols = shuffle([0,1,2,3]);

      let placed = false;
      for (const col of cols){
        const row = findDropRow("ai", col);
        if (row === null) continue;
        const res = deployFromHand("ai", choice.idx, col);
        if (res.ok){ placed = true; break; }
      }
      if (!placed) break;
    }

    renderAll();
    endTurn();
  }

  // ================== INPUT ==================
  btnEndTurn.onclick = () => {
    if (activeSide !== "player") return;
    endTurn();
  };

  function onClickCell(r,c){
    if (activeSide !== "player") return;
    if (selectedHandIndex === null) return;

    const card = player.hand[selectedHandIndex];
    const cost = costToDeploy(card);

    if (ap < cost){
      log(`Not enough points to play ${card.name} (need ${cost}).`, true);
      return;
    }

    const row = findDropRow("player", c);
    if (row === null){
      log(`Lane ${c+1} is full.`, true);
      return;
    }

    const res = deployFromHand("player", selectedHandIndex, c);
    if (res.ok){
      selectedHandIndex = null;
      selLabel.textContent = "None";
      renderAll();
    }
  }

  // ================== RENDER ==================
  function renderGrid(){
    gridEl.innerHTML = "";
    for (let r=0;r<4;r++){
      for (let c=0;c<4;c++){
        const u = board[r][c];
        const cell = document.createElement("div");
        cell.className = "cell" + (u ? "" : " empty");
        cell.onclick = () => onClickCell(r,c);

        if (u){
          // Show player units face-up always.
          // Show AI units face-down until revealed.
          const showFaceUp = (u.side === "player") ? true : !!u.revealed;

          if (showFaceUp){
            const img = document.createElement("img");
            img.className = "unitImg";
            img.src = u.card.image;
            img.alt = u.card.name;
            cell.appendChild(img);

            const hp = document.createElement("div");
            hp.className = "hpTag" + (u.side==="ai" ? " ai" : "");
            hp.innerHTML = `<span class="dot"></span><span>${u.hp}</span>`;
            cell.appendChild(hp);

            const tier = deriveTier(u.card);
            const acc = Number(u.card.stats.accuracy ?? 0);
            const bottom = document.createElement("div");
            bottom.className = "tagBottom";
            bottom.textContent = `T${tier} ‚Ä¢ ACC ${acc}`;
            cell.appendChild(bottom);
          } else {
            const back = document.createElement("div");
            back.className = "cardBack";
            back.textContent = "UNKNOWN";
            cell.appendChild(back);

            // hide HP and stats while face-down
            const bottom = document.createElement("div");
            bottom.className = "tagBottom";
            bottom.textContent = `Face-down`;
            cell.appendChild(bottom);
          }

          const side = document.createElement("div");
          side.className = "sideMark";
          side.textContent = (u.side==="player") ? "YOU" : "AI";
          cell.appendChild(side);
        }

        gridEl.appendChild(cell);
      }
    }
  }

  function renderHand(){
    playerHandEl.innerHTML = "";
    for (let i=0;i<player.hand.length;i++){
      const card = player.hand[i];
      const tier = deriveTier(card);
      const cost = costToDeploy(card);

      const div = document.createElement("div");
      div.className = "handCard" + (selectedHandIndex===i ? " selected" : "");
      div.innerHTML = `
        <img src="${card.image}" alt="${escapeHtml(card.name)}">
        <div class="mini">T${tier} ‚Ä¢ Cost ${cost}</div>
      `;
      div.onclick = () => {
        if (activeSide !== "player") return;
        selectedHandIndex = (selectedHandIndex === i) ? null : i;
        selLabel.textContent = selectedHandIndex===null
          ? "None"
          : `${player.hand[selectedHandIndex].name} (Tier ${deriveTier(player.hand[selectedHandIndex])}, cost ${costToDeploy(player.hand[selectedHandIndex])})`;
        renderAll();
      };
      playerHandEl.appendChild(div);
    }
  }

  function renderCounts(){
    playerCountEl.textContent = `Deck ${player.deck.length} ‚Ä¢ Hand ${player.hand.length} ‚Ä¢ Board ${countBoardUnits("player")}`;
    aiCountEl.textContent = `Deck ${ai.deck.length} ‚Ä¢ Hand ${ai.hand.length} ‚Ä¢ Board ${countBoardUnits("ai")}`;

    youLabel.textContent = titleCase(player.faction);
    aiLabel.textContent = titleCase(ai.faction);
  }

  function renderTop(){
    apText.textContent = String(ap);
    btnEndTurn.disabled = (activeSide !== "player");

    sideSub.textContent = activeSide === "player"
      ? `Round ${round} ‚Ä¢ Your turn`
      : `Round ${round} ‚Ä¢ AI turn`;

    turnText.textContent = activeSide === "player"
      ? `Round ${round}: You have ${ap} point(s). Play cards, then End Turn (auto-attack happens).`
      : `Round ${round}: AI is playing‚Ä¶`;

    statusText.textContent = "";
  }

  function renderAll(){
    renderTop();
    renderGrid();
    renderHand();
    renderCounts();
  }

  // ================== SETUP ==================
  function populateSetupSelectors(){
    const available = factions.map(f => f.faction);

    playerFactionSel.innerHTML = "";
    aiFactionSel.innerHTML = "";

    for (const f of available){
      const opt1 = document.createElement("option");
      opt1.value = f;
      opt1.textContent = titleCase(f);
      playerFactionSel.appendChild(opt1);

      const opt2 = document.createElement("option");
      opt2.value = f;
      opt2.textContent = titleCase(f);
      aiFactionSel.appendChild(opt2);
    }

    // default to germany vs allies if present
    if (available.includes("germany")) playerFactionSel.value = "germany";
    if (available.includes("allies")) aiFactionSel.value = "allies";
    if (playerFactionSel.value === aiFactionSel.value && available.length > 1){
      aiFactionSel.value = available.find(x => x !== playerFactionSel.value) || available[0];
    }
  }

  function startGame(){
    const pf = playerFactionSel.value;
    const af = aiFactionSel.value;

    const pBlock = factions.find(f => f.faction === pf);
    const aBlock = factions.find(f => f.faction === af);

    if (!pBlock || !aBlock) {
      alert("Missing faction data in tanks.json.");
      return;
    }

    player = { side:"player", faction: pf, deck: makeDeck(pBlock.cards), hand: [] };
    ai     = { side:"ai",     faction: af, deck: makeDeck(aBlock.cards), hand: [] };

    board = Array.from({length:4}, () => Array.from({length:4}, () => null));
    UID = 0;
    round = 1;
    logEl.innerHTML = "";

    log(`Game start: You = ${titleCase(pf)} vs AI = ${titleCase(af)}.`);
    log(`Face-down plays ‚Üí next owner turn advances 1 row and flips face-up. Auto-attacks at end of turn.`, true);

    elSetup.classList.add("hidden");
    elGame.classList.remove("hidden");
    btnRestart.classList.remove("hidden");

    beginTurn("player");
  }

  function resetToSetup(){
    elGame.classList.add("hidden");
    elSetup.classList.remove("hidden");
    btnRestart.classList.add("hidden");
    logEl.innerHTML = "";
  }

  btnStart.addEventListener("click", startGame);
  btnRestart.addEventListener("click", resetToSetup);

  // ================== INIT ==================
  (async function init(){
    try{
      const res = await fetch(DATA_URL, { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to load tanks.json (${res.status})`);
      const data = await res.json();
      factions = data.factions || [];
      populateSetupSelectors();
    }catch(err){
      alert(err.message + "\n\nIf you opened this as file://, use a local server (python3 -m http.server).");
    }
  })();
</script>
</body>
</html>
