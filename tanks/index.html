<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tankers â€” Inscryption Lanes</title>
  <style>
    :root{
      --bg:#0c0f14;
      --text:#e7edf7;
      --muted:#9bb0cc;
      --line:rgba(255,255,255,.10);
      --accent:#f7c34a;
      --good:#62ff9b;
      --bad:#ff5b5b;
      --radius:14px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 700px at 15% 0%, rgba(247,195,74,.12), transparent 55%),
                  radial-gradient(1000px 600px at 90% 20%, rgba(80,180,255,.10), transparent 55%),
                  var(--bg);
      color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:10;
      backdrop-filter: blur(10px);
      background: rgba(12,15,20,.70);
      border-bottom:1px solid var(--line);
    }
    .wrap{max-width:1200px;margin:0 auto;padding:16px;}
    .top{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap;}
    .brand{display:flex;align-items:center;gap:10px;font-weight:900;letter-spacing:.4px;}
    .badge{font-size:12px;color:#111;background:var(--accent);padding:4px 8px;border-radius:999px;font-weight:900;}
    .btn{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color:var(--text);
      padding:9px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:900;
    }
    .btn:hover{border-color: rgba(247,195,74,.45)}
    .btn:disabled{opacity:.45; cursor:not-allowed}
    select{
      border:1px solid var(--line);
      background: rgba(255,255,255,.05);
      color:var(--text);
      padding:9px 12px;
      border-radius:12px;
      font-weight:800;
      outline:none;
    }

    .layout{
      display:grid;
      grid-template-columns: 1fr 340px;
      gap:14px;
    }
    @media (max-width: 980px){ .layout{grid-template-columns:1fr;} }

    .setup{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      padding:14px;
    }
    .setup h2{margin:0 0 8px 0;font-size:18px;}
    .setup p{margin:0 0 14px 0;color:var(--muted);font-size:13px;line-height:1.35;}
    .setupRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .setupCol{display:flex;flex-direction:column;gap:6px;min-width:220px}
    .setupCol label{color:var(--muted);font-size:12px;font-weight:900;letter-spacing:.08em;text-transform:uppercase}

    .board{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      overflow:hidden;
    }
    .boardTop{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:10px;
      flex-wrap:wrap;
    }
    .boardTop .title{font-weight:900;letter-spacing:.3px;}
    .boardTop .sub{color:var(--muted);font-size:12px;line-height:1.2;}

    .grid{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      padding:12px;
    }
    .cell{
      aspect-ratio: 3/4;
      border-radius:14px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      position:relative;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
    }
    .cell.empty::after{
      content:"";
      position:absolute; inset:0;
      background: radial-gradient(400px 240px at 50% 20%, rgba(255,255,255,.06), transparent 55%);
      opacity:.9;
      pointer-events:none;
    }
    .cell.hilite{border-color: rgba(247,195,74,.85); box-shadow: 0 0 0 3px rgba(247,195,74,.14);}

    .unitImg{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      pointer-events:none;
    }
    .cardBack{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        radial-gradient(900px 500px at 30% 20%, rgba(247,195,74,.18), transparent 60%),
        radial-gradient(700px 420px at 80% 70%, rgba(80,180,255,.14), transparent 60%),
        rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      color: rgba(231,237,247,.75);
      font-weight:1000;
      letter-spacing:.18em;
      text-transform:uppercase;
      pointer-events:none;
    }
    .hpTag{
      position:absolute;
      left:8px; top:8px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      padding:4px 8px;
      font-size:12px;
      font-weight:900;
      display:flex;
      gap:6px;
      align-items:center;
      pointer-events:none;
    }
    .hpTag .dot{
      width:8px;height:8px;border-radius:999px;background: var(--good);
      box-shadow: 0 0 0 3px rgba(98,255,155,.12);
    }
    .hpTag.ai .dot{background: var(--bad); box-shadow: 0 0 0 3px rgba(255,91,91,.12);}
    .sideMark{
      position:absolute;
      right:8px; top:8px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      padding:4px 8px;
      font-size:11px;
      color:var(--muted);
      font-weight:900;
      letter-spacing:.08em;
      text-transform:uppercase;
      pointer-events:none;
    }
    .tagBottom{
      position:absolute;
      left:8px; bottom:8px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      padding:4px 8px;
      font-size:11px;
      color:var(--muted);
      font-weight:900;
      pointer-events:none;
    }

    .hands{
      border-top:1px solid var(--line);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .handTitle{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      color:var(--muted);
      font-size:12px;
      font-weight:900;
      letter-spacing:.08em;
      text-transform:uppercase;
    }
    .handRow{
      display:grid;
      grid-template-columns: repeat(5, minmax(0,1fr));
      gap:10px;
    }
    @media (max-width:700px){ .handRow{grid-template-columns: repeat(4, 1fr);} }
    @media (max-width:520px){ .handRow{grid-template-columns: repeat(3, 1fr);} }

    .handCard{
      border:1px solid var(--line);
      border-radius:14px;
      overflow:hidden;
      background: rgba(0,0,0,.18);
      cursor:pointer;
      position:relative;
      aspect-ratio: 2/3;
      transition: transform .08s ease, border-color .08s ease;
    }
    .handCard:hover{transform: translateY(-2px); border-color: rgba(247,195,74,.45);}
    .handCard.selected{
      border-color: rgba(247,195,74,.85);
      box-shadow: 0 0 0 3px rgba(247,195,74,.16);
    }
    .handCard img{width:100%;height:100%;object-fit:cover;display:block; pointer-events:none;}
    .handCard .mini{
      position:absolute;
      left:8px; bottom:8px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.14);
      border-radius:999px;
      padding:4px 8px;
      font-size:12px;
      font-weight:900;
      display:flex;
      gap:8px;
      align-items:center;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      font-weight:900;
      font-size:12px;
    }
    .pill .dot{
      width:8px;height:8px;border-radius:999px;background: var(--accent);
      box-shadow: 0 0 0 3px rgba(247,195,74,.12);
    }

    .side{
      border:1px solid var(--line);
      border-radius: var(--radius);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      overflow:hidden;
      display:flex;
      flex-direction:column;
      min-height: 560px;
    }
    .sideTop{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--line);
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:10px;
      flex-wrap:wrap;
    }
    .sideTop .title{font-weight:900;letter-spacing:.3px;}
    .sideTop .sub{color:var(--muted);font-size:12px;}
    .panel{padding:12px; display:flex; flex-direction:column; gap:10px;}
    .kv{
      display:flex; justify-content:space-between; gap:10px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius:12px;
      padding:10px 10px;
      font-size:13px;
    }
    .kv span{color:var(--muted);font-weight:900}
    .kv b{font-weight:900}

    .log{
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      border-radius:12px;
      padding:10px;
      height: 330px;
      overflow:auto;
      font-size:12px;
      line-height:1.35;
      color: rgba(231,237,247,.92);
    }
    .log .muted{color: var(--muted)}
    .note{color:var(--muted);font-size:12px;line-height:1.35;}
    .hidden{display:none!important}
    code{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <div class="top">
      <div class="brand">
        <span style="font-size:18px;">ðŸª–</span>
        <span>Tankers</span>
        <span class="badge">Lanes + Face-down + Direct Hits</span>
      </div>
      <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
        <button class="btn hidden" id="btnRestart">Restart</button>
      </div>
    </div>
  </div>
</header>

<main>
  <div class="wrap">
    <div id="setup" class="setup">
      <h2>Start Game</h2>
      <p>
        Each round you get points equal to the round number (1, 2, 3...). Deploy cost = <b>Tier</b> from <code>tanks.json</code>.
        Cards are played <b>face-down to the opponent</b>, then on the owner's <b>next</b> turn they <b>flip active</b>.
        End of turn: active tanks auto-shoot down their lane. If no enemy tank blocks the lane â†’ <b>direct hit</b> to the opponent.
      </p>
      <div class="setupRow">
        <div class="setupCol">
          <label for="playerFaction">Your faction</label>
          <select id="playerFaction"></select>
        </div>
        <div class="setupCol">
          <label for="aiFaction">Opponent faction</label>
          <select id="aiFaction"></select>
        </div>
        <div class="setupCol" style="min-width:auto;">
          <label>&nbsp;</label>
          <button class="btn" id="btnStart">Start</button>
        </div>
      </div>
      <div class="note" style="margin-top:10px;">
        If images donâ€™t load, run: <code>python3 -m http.server 8080</code> then open <code>http://localhost:8080/tankers.html</code>.
      </div>
    </div>

    <div id="game" class="layout hidden">
      <div class="board">
        <div class="boardTop">
          <div>
            <div class="title">Battlefield (4 lanes)</div>
            <div class="sub" id="turnText">â€”</div>
          </div>
          <div class="sub" id="statusText">â€”</div>
        </div>

        <div class="grid" id="grid"></div>

        <div class="hands">
          <div class="handTitle">
            <div>Your hand (select a card â†’ click a column to play)</div>
            <div id="playerCount" class="muted"></div>
          </div>
          <div class="handRow" id="playerHand"></div>

          <div class="handTitle">
            <div>Opponent hand (hidden)</div>
            <div id="aiCount" class="muted"></div>
          </div>
        </div>
      </div>

      <div class="side">
        <div class="sideTop">
          <div>
            <div class="title">Turn</div>
            <div class="sub" id="sideSub">â€”</div>
          </div>
          <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;">
            <span class="pill"><span class="dot"></span><span>Points:</span><b id="apText">0</b></span>
            <button class="btn" id="btnEndTurn">End Turn</button>
          </div>
        </div>

        <div class="panel">
          <div class="kv"><span>You</span><b id="youLabel">â€”</b></div>
          <div class="kv"><span>Opponent</span><b id="aiLabel">â€”</b></div>

          <div class="kv"><span>Your Base HP</span><b id="pBase">â€”</b></div>
          <div class="kv"><span>Enemy Base HP</span><b id="aBase">â€”</b></div>

          <div class="kv"><span>Selected card</span><b id="selLabel">None</b></div>

          <div class="note">
            <b>Face-down rule:</b> A played tank is inactive until it flips on its ownerâ€™s next turn.<br>
            <b>Lane shots:</b> Active tanks shoot the nearest enemy in the same column within <b>Accuracy</b> range.
            If there are <b>no enemy tanks anywhere</b> in that lane â†’ direct hit to base.
          </div>

          <div class="log" id="log"></div>
        </div>
      </div>
    </div>
  </div>
</main>

<script>
  // ================== CONFIG ==================
  const DATA_URL = "tanks.json";
  const HAND_SIZE = 5;
  const COPIES_PER_CARD = 2;

  const BASE_HP_START = 20;

  // ================== STATE ==================
  let factions = [];
  let player = null;
  let ai = null;

  // board rows 0..3 top->bottom, cols 0..3 left->right
  // cell null or unit { uid, side, card, hp, active, deployedTurn }
  let board = null;
  let UID = 0;

  let round = 1;
  let activeSide = "player"; // "player" | "ai"
  let ap = 0;

  let turnNumber = 0; // increments each beginTurn()

  let playerBaseHP = BASE_HP_START;
  let aiBaseHP = BASE_HP_START;

  let selectedHandIndex = null;

  // ================== DOM ==================
  const elSetup = document.getElementById("setup");
  const elGame = document.getElementById("game");
  const playerFactionSel = document.getElementById("playerFaction");
  const aiFactionSel = document.getElementById("aiFaction");
  const btnStart = document.getElementById("btnStart");
  const btnRestart = document.getElementById("btnRestart");

  const gridEl = document.getElementById("grid");
  const logEl = document.getElementById("log");
  const turnText = document.getElementById("turnText");
  const statusText = document.getElementById("statusText");

  const playerHandEl = document.getElementById("playerHand");
  const playerCountEl = document.getElementById("playerCount");
  const aiCountEl = document.getElementById("aiCount");

  const youLabel = document.getElementById("youLabel");
  const aiLabel = document.getElementById("aiLabel");
  const selLabel = document.getElementById("selLabel");
  const sideSub = document.getElementById("sideSub");
  const apText = document.getElementById("apText");
  const pBaseEl = document.getElementById("pBase");
  const aBaseEl = document.getElementById("aBase");

  const btnEndTurn = document.getElementById("btnEndTurn");

  // ================== HELPERS ==================
  const titleCase = (s) => (s || "").replace(/[_-]/g," ").replace(/\b\w/g, c => c.toUpperCase()).trim();

  function escapeHtml(s){
    return String(s ?? "").replace(/[&<>"']/g, c => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[c]));
  }

  function log(line, muted=false){
    const div = document.createElement("div");
    div.innerHTML = muted ? `<span class="muted">${escapeHtml(line)}</span>` : escapeHtml(line);
    logEl.appendChild(div);
    logEl.scrollTop = logEl.scrollHeight;
  }

  function shuffle(arr){
    const a = [...arr];
    for (let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }

  function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }

  function makeDeck(cards){
    const deck = [];
    for (const c of cards){
      for (let i=0;i<COPIES_PER_CARD;i++) deck.push(deepCopy(c));
    }
    return shuffle(deck);
  }

  function drawToHand(sideObj){
    while (sideObj.hand.length < HAND_SIZE && sideObj.deck.length){
      sideObj.hand.push(sideObj.deck.pop());
    }
  }

  function countBoardUnits(side){
    let n=0;
    for (let r=0;r<4;r++) for (let c=0;c<4;c++){
      const u = board[r][c];
      if (u && u.side === side) n++;
    }
    return n;
  }

  // ================== TIER / COST ==================
  function clampTier(t){
    if (!Number.isFinite(t)) return 1;
    return Math.max(1, Math.min(9, t));
  }

  function deriveTier(card){
    const raw = Number(card?.tier);
    if (!Number.isFinite(raw)){
      console.warn("Missing tier on card:", card?.id, card?.name);
      return 1;
    }
    return clampTier(raw);
  }

  function costToDeploy(card){
    return deriveTier(card);
  }

  // ================== DEPLOY (face-down/inactive) ==================
  function findDropRow(side, col){
    // Only allow placing in the "first" square closest to the player
    const r = (side === "player") ? 3 : 0; // player bottom row, AI top row
    return board[r][col] ? null : r;
  }

  function deployFromHand(side, handIndex, col){
    const who = side === "player" ? player : ai;
    const row = findDropRow(side, col);
    if (row === null) return { ok:false, reason:"Lane full." };

    const card = who.hand[handIndex];
    const cost = costToDeploy(card);
    if (ap < cost) return { ok:false, reason:`Not enough points (need ${cost}).` };

    ap -= cost;
    const played = who.hand.splice(handIndex, 1)[0];

    board[row][col] = {
      uid: ++UID,
      side,
      card: played,
      hp: Number(played.stats.hp ?? 1),
      active: false,        // flips on owner's next turn
      deployedTurn: turnNumber
    };

    log(`${titleCase(side)} plays a card face-down in lane ${col+1} (cost ${cost}).`);
    return { ok:true };
  }

  // ================== FLIP ON OWNER'S NEXT TURN ==================
  function flipNewUnits(side){
    let flips = 0;
    for (let r=0;r<4;r++) for (let c=0;c<4;c++){
      const u = board[r][c];
      if (!u || u.side !== side) continue;
      if (u.active) continue;

      // strict: must have been deployed on a previous turn (not this same turn)
      if (u.deployedTurn < turnNumber){
        u.active = true;
        flips++;
      }
    }
    if (flips) log(`${titleCase(side)} flips ${flips} unit(s) active.`, true);
  }

  // ================== AUTO ATTACK (END OF TURN) ==================
  function findNearestEnemyInLane(attackerPos){
    const attacker = board[attackerPos.r][attackerPos.c];
    if (!attacker) return null;

    const dir = attacker.side === "player" ? -1 : +1;
    const range = Math.max(1, Number(attacker.card.stats.accuracy ?? 1));

    for (let step=1; step<=range; step++){
      const rr = attackerPos.r + dir*step;
      if (rr < 0 || rr > 3) break;
      const t = board[rr][attackerPos.c];
      if (t && t.side !== attacker.side) return { r: rr, c: attackerPos.c };
    }
    return null;
  }

  function laneHasAnyEnemy(attackerSide, col){
    for (let r=0;r<4;r++){
      const u = board[r][col];
      if (u && u.side !== attackerSide) return true;
    }
    return false;
  }

  function computeDamageToUnit(attackerUnit, targetUnit){
    const firepower = Number(attackerUnit.card.stats.firepower ?? 1);
    const armor = Number(targetUnit.card.stats.armor ?? 0);
    return Math.max(1, firepower - Math.floor(armor / 2));
  }

  function computeDirectDamage(attackerUnit){
    // direct damage = firepower (simple, tweak later)
    return Math.max(1, Number(attackerUnit.card.stats.firepower ?? 1));
  }

  function autoAttack(side){
    // resolve front-to-back in direction (so it feels consistent)
    const rows = side === "player" ? [0,1,2,3] : [3,2,1,0];
    let didAnything = false;

    for (const r of rows){
      for (let c=0;c<4;c++){
        const u = board[r][c];
        if (!u || u.side !== side) continue;
        if (!u.active) continue; // only flipped units can shoot

        const targetPos = findNearestEnemyInLane({r,c});
        if (targetPos){
          const t = board[targetPos.r][targetPos.c];
          if (!t) continue;

          const dmg = computeDamageToUnit(u, t);
          t.hp -= dmg;
          didAnything = true;

          const aName = (side === "player") ? "You" : "AI";
          const tName = (t.side === "player") ? "You" : "AI";
          log(`${aName} ${u.card.name} shoots lane ${c+1} â†’ ${tName} unit for ${dmg}.`);

          if (t.hp <= 0){
            log(`${tName} unit in lane ${c+1} is destroyed!`);
            board[targetPos.r][targetPos.c] = null;
          }
        } else {
          // no enemy in range: if lane has NO enemy tanks at all, direct hit base
          if (!laneHasAnyEnemy(side, c)){
            const direct = computeDirectDamage(u);
            didAnything = true;

            if (side === "player"){
              aiBaseHP -= direct;
              log(`You ${u.card.name} fires lane ${c+1} â†’ DIRECT HIT for ${direct}! (Enemy base ${aiBaseHP})`);
            } else {
              playerBaseHP -= direct;
              log(`AI ${u.card.name} fires lane ${c+1} â†’ DIRECT HIT for ${direct}! (Your base ${playerBaseHP})`);
            }
          } else {
            // blocked somewhere down-lane, but out of range â†’ no shot
            log(`${titleCase(side)} ${u.card.name} canâ€™t reach a target in lane ${c+1}.`, true);
          }
        }

        if (playerBaseHP <= 0 || aiBaseHP <= 0) return; // stop immediately if someone dies
      }
    }

    if (!didAnything) log(`${titleCase(side)}: no attacks.`, true);
  }

  // ================== TURN FLOW ==================
  function beginTurn(side){
    activeSide = side;
    turnNumber += 1;

    ap = round; // points = round number

    // draw at start of turn
    const who = (side === "player") ? player : ai;
    drawToHand(who);

    // flip inactive units from earlier turns
    flipNewUnits(side);

    selectedHandIndex = null;
    selLabel.textContent = "None";

    renderAll();
    log(`â€” Round ${round}: ${side === "player" ? "Your" : "AI"} turn (${ap} point${ap===1?"":"s"}).`, true);
  }

  function endTurn(){
    if (checkEnd()) return;

    // end of turn: auto attack
    autoAttack(activeSide);
    renderAll();

    if (checkEnd()) return;

    // next side
    if (activeSide === "player"){
      beginTurn("ai");
      window.setTimeout(aiTurn, 450);
    } else {
      round += 1;
      beginTurn("player");
    }
  }

  function checkEnd(){
    if (aiBaseHP <= 0){ gameOver("You win â€” enemy base destroyed!"); return true; }
    if (playerBaseHP <= 0){ gameOver("You lose â€” your base was destroyed!"); return true; }
    return false;
  }

  function gameOver(msg){
    statusText.textContent = msg;
    turnText.textContent = "Game over.";
    btnRestart.classList.remove("hidden");
    btnEndTurn.disabled = true;
    log(msg);
    renderAll();
  }

  // ================== AI (simple) ==================
  function aiTurn(){
    if (activeSide !== "ai") return;

    // deploy cheapest-first while possible
    let safety = 60;
    while (ap > 0 && ai.hand.length > 0 && safety-- > 0){
      const affordable = ai.hand
        .map((card, idx) => ({card, idx, cost: costToDeploy(card)}))
        .filter(x => x.cost <= ap);

      if (!affordable.length) break;
      affordable.sort((a,b)=>a.cost-b.cost);

      const choice = affordable[0];
      const cols = shuffle([0,1,2,3]);

      let placed = false;
      for (const col of cols){
        const row = findDropRow("ai", col);
        if (row === null) continue;
        const res = deployFromHand("ai", choice.idx, col);
        if (res.ok){ placed = true; break; }
      }
      if (!placed) break;
    }

    renderAll();
    endTurn();
  }

  // ================== INPUT ==================
  btnEndTurn.onclick = () => {
    if (activeSide !== "player") return;
    endTurn();
  };

  function onClickCell(r,c){
    if (activeSide !== "player") return;
    if (selectedHandIndex === null) return;

    const backRow = 3;
    if (r !== backRow){
      log("You can only place cards on your back row (bottom row).", true);
      return;
    }

    const card = player.hand[selectedHandIndex];
    const cost = costToDeploy(card);

    if (ap < cost){
      log(`Not enough points to play ${card.name} (need ${cost}).`, true);
      return;
    }

    const row = findDropRow("player", c);
    if (row === null){
      log(`Lane ${c+1} is full.`, true);
      return;
    }

    const res = deployFromHand("player", selectedHandIndex, c);
    if (res.ok){
      selectedHandIndex = null;
      selLabel.textContent = "None";
      renderAll();
    }
  }

  // ================== RENDER ==================
  function renderGrid(){
    gridEl.innerHTML = "";
    for (let r=0;r<4;r++){
      for (let c=0;c<4;c++){
        const u = board[r][c];
        const cell = document.createElement("div");
        cell.className = "cell" + (u ? "" : " empty");
        cell.onclick = () => onClickCell(r,c);

        if (u){
          const ownerSeesFaceUp = (u.side === "player"); // you see your own cards immediately
          const opponentSeesFaceUp = u.active;           // enemy sees it only after flip

          const showFaceUp = ownerSeesFaceUp || opponentSeesFaceUp;

          if (showFaceUp){
            const img = document.createElement("img");
            img.className = "unitImg";
            img.src = u.card.image;
            img.alt = u.card.name;
            cell.appendChild(img);

            const hp = document.createElement("div");
            hp.className = "hpTag" + (u.side==="ai" ? " ai" : "");
            hp.innerHTML = `<span class="dot"></span><span>${u.hp}</span>`;
            cell.appendChild(hp);

            const tier = deriveTier(u.card);
            const acc = Number(u.card.stats.accuracy ?? 0);
            const bottom = document.createElement("div");
            bottom.className = "tagBottom";
            bottom.textContent = u.active ? `ACTIVE â€¢ T${tier} â€¢ ACC ${acc}` : `FACE-DOWN â€¢ T${tier}`;
            cell.appendChild(bottom);
          } else {
            const back = document.createElement("div");
            back.className = "cardBack";
            back.textContent = "UNKNOWN";
            cell.appendChild(back);

            const bottom = document.createElement("div");
            bottom.className = "tagBottom";
            bottom.textContent = `FACE-DOWN`;
            cell.appendChild(bottom);
          }

          const side = document.createElement("div");
          side.className = "sideMark";
          side.textContent = (u.side==="player") ? "YOU" : "AI";
          cell.appendChild(side);
        }

        gridEl.appendChild(cell);
      }
    }
  }

  function renderHand(){
    playerHandEl.innerHTML = "";
    for (let i=0;i<player.hand.length;i++){
      const card = player.hand[i];
      const tier = deriveTier(card);
      const cost = costToDeploy(card);

      const div = document.createElement("div");
      div.className = "handCard" + (selectedHandIndex===i ? " selected" : "");
      div.innerHTML = `
        <img src="${card.image}" alt="${escapeHtml(card.name)}">
        <div class="mini">T${tier} â€¢ Cost ${cost}</div>
      `;
      div.onclick = () => {
        if (activeSide !== "player") return;
        selectedHandIndex = (selectedHandIndex === i) ? null : i;
        selLabel.textContent = selectedHandIndex===null
          ? "None"
          : `${player.hand[selectedHandIndex].name} (Tier ${deriveTier(player.hand[selectedHandIndex])}, cost ${costToDeploy(player.hand[selectedHandIndex])})`;
        renderAll();
      };
      playerHandEl.appendChild(div);
    }
  }

  function renderCounts(){
    playerCountEl.textContent = `Deck ${player.deck.length} â€¢ Hand ${player.hand.length} â€¢ Board ${countBoardUnits("player")}`;
    aiCountEl.textContent = `Deck ${ai.deck.length} â€¢ Hand ${ai.hand.length} â€¢ Board ${countBoardUnits("ai")} (hidden)`;

    youLabel.textContent = titleCase(player.faction);
    aiLabel.textContent = titleCase(ai.faction);

    pBaseEl.textContent = String(playerBaseHP);
    aBaseEl.textContent = String(aiBaseHP);
  }

  function renderTop(){
    apText.textContent = String(ap);
    btnEndTurn.disabled = (activeSide !== "player");

    sideSub.textContent = activeSide === "player"
      ? `Round ${round} â€¢ Your turn`
      : `Round ${round} â€¢ AI turn`;

    turnText.textContent = activeSide === "player"
      ? `Round ${round}: You have ${ap} point(s). Play cards (face-down), then End Turn (auto-attacks fire).`
      : `Round ${round}: AI is playingâ€¦`;

    statusText.textContent = "";
  }

  function renderAll(){
    renderTop();
    renderGrid();
    renderHand();
    renderCounts();
  }

  // ================== SETUP ==================
  function populateSetupSelectors(){
    const available = factions.map(f => f.faction);

    playerFactionSel.innerHTML = "";
    aiFactionSel.innerHTML = "";

    for (const f of available){
      const opt1 = document.createElement("option");
      opt1.value = f;
      opt1.textContent = titleCase(f);
      playerFactionSel.appendChild(opt1);

      const opt2 = document.createElement("option");
      opt2.value = f;
      opt2.textContent = titleCase(f);
      aiFactionSel.appendChild(opt2);
    }

    if (available.includes("germany")) playerFactionSel.value = "germany";
    if (available.includes("allies")) aiFactionSel.value = "allies";
    if (playerFactionSel.value === aiFactionSel.value && available.length > 1){
      aiFactionSel.value = available.find(x => x !== playerFactionSel.value) || available[0];
    }
  }

  function startGame(){
    const pf = playerFactionSel.value;
    const af = aiFactionSel.value;

    const pBlock = factions.find(f => f.faction === pf);
    const aBlock = factions.find(f => f.faction === af);

    if (!pBlock || !aBlock) {
      alert("Missing faction data in tanks.json.");
      return;
    }

    player = { side:"player", faction: pf, deck: makeDeck(pBlock.cards), hand: [] };
    ai     = { side:"ai",     faction: af, deck: makeDeck(aBlock.cards), hand: [] };

    board = Array.from({length:4}, () => Array.from({length:4}, () => null));
    UID = 0;

    round = 1;
    turnNumber = 0;
    playerBaseHP = BASE_HP_START;
    aiBaseHP = BASE_HP_START;

    logEl.innerHTML = "";
    log(`Game start: You = ${titleCase(pf)} vs AI = ${titleCase(af)}.`);
    log(`Played cards are inactive until they flip on their ownerâ€™s next turn. Auto-attacks at end of turn. Direct hit if lane is clear.`, true);

    elSetup.classList.add("hidden");
    elGame.classList.remove("hidden");
    btnRestart.classList.remove("hidden");

    beginTurn("player");
  }

  function resetToSetup(){
    elGame.classList.add("hidden");
    elSetup.classList.remove("hidden");
    btnRestart.classList.add("hidden");
    logEl.innerHTML = "";
  }

  btnStart.addEventListener("click", startGame);
  btnRestart.addEventListener("click", resetToSetup);

  // ================== INIT ==================
  (async function init(){
    try{
      const res = await fetch(DATA_URL, { cache: "no-store" });
      if (!res.ok) throw new Error(`Failed to load tanks.json (${res.status})`);
      const data = await res.json();
      factions = data.factions || [];
      populateSetupSelectors();
    }catch(err){
      alert(err.message + "\n\nIf you opened this as file://, use a local server (python3 -m http.server).");
    }
  })();
</script>
</body>
</html>
