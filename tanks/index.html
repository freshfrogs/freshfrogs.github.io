<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tankers — Lanes</title>
  <style>
    :root{
      --bg:#0d0f12;
      --panel:#151920;
      --panel2:#10141a;
      --brass:#caa55a;
      --text:#e8edf6;
      --muted:#9aa7bd;
      --good:#65d67a;
      --bad:#ff4b4b;
      --warn:#ffd166;
      --line: rgba(255,255,255,.08);
      --shadow: 0 10px 30px rgba(0,0,0,.45);
      --radius:14px;
      --gap:12px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 30% -10%, rgba(202,165,90,.12), transparent 55%),
        radial-gradient(1200px 700px at 80% 0%, rgba(101,214,122,.08), transparent 55%),
        linear-gradient(180deg, #0b0d11 0%, #0a0c10 35%, #07090c 100%);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
      min-height:100vh;
    }

    .wrap{
      max-width:1200px;
      margin:0 auto;
      padding:18px 16px 28px;
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
      margin-bottom:12px;
    }

    .title{
      display:flex;
      align-items:baseline;
      gap:10px;
      flex-wrap:wrap;
    }
    .title h1{
      margin:0;
      letter-spacing:.06em;
      font-size:20px;
      text-transform:uppercase;
      color:#f5f7ff;
    }
    .title .sub{
      font-size:12px;
      color:var(--muted);
      letter-spacing:.02em;
    }

    .topbar{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .pill{
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      box-shadow: 0 8px 18px rgba(0,0,0,.18);
      font-size:12px;
      color:var(--muted);
      user-select:none;
    }
    .pill strong{color:var(--text); font-weight:800}

    .btn{
      cursor:pointer;
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
      color:var(--text);
      border-radius:12px;
      padding:10px 12px;
      font-weight:800;
      letter-spacing:.02em;
      box-shadow: var(--shadow);
    }
    .btn:hover{filter:brightness(1.07)}
    .btn:disabled{
      cursor:not-allowed;
      opacity:.5;
      filter:none;
      box-shadow:none;
    }
    .btn.primary{
      border-color: rgba(202,165,90,.35);
      background: linear-gradient(180deg, rgba(202,165,90,.22), rgba(202,165,90,.08));
    }

    select{
      background: rgba(255,255,255,.06);
      color: var(--text);
      border:1px solid var(--line);
      padding:10px 12px;
      border-radius:12px;
      font-weight:800;
      outline:none;
    }

    .gridShell{
      display:grid;
      grid-template-columns: 1fr 330px;
      gap:14px;
      margin-top:12px;
    }
    @media (max-width: 980px){
      .gridShell{grid-template-columns:1fr}
    }

    .board{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:12px;
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .board::before{
      content:"";
      position:absolute;
      inset:-2px;
      background:
        radial-gradient(800px 400px at 50% 0%, rgba(202,165,90,.10), transparent 55%),
        radial-gradient(800px 400px at 50% 100%, rgba(101,214,122,.07), transparent 55%);
      pointer-events:none;
      filter: blur(.2px);
    }
    .boardInner{position:relative}

    .hpbar{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      margin-bottom:12px;
    }
    .hpBox{
      flex:1;
      background: rgba(0,0,0,.25);
      border:1px solid var(--line);
      border-radius: 14px;
      padding:10px 12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .hpBox .who{
      font-weight:1000;
      letter-spacing:.08em;
      text-transform:uppercase;
      font-size:12px;
      color: var(--muted);
    }
    .hpBox .hp{
      font-weight:1000;
      font-size:16px;
    }
    .hpBox .hp.good{color:var(--good)}
    .hpBox .hp.bad{color:var(--bad)}

    .laneHints{
      display:flex;
      justify-content:space-between;
      gap:10px;
      margin:0 2px 10px;
      font-size:12px;
      color:var(--muted);
      letter-spacing:.06em;
      text-transform:uppercase;
    }

    /* 4 lanes, each lane has 4 slots (opp front/back, player front/back) */
    .lanes{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: var(--gap);
    }
    .lane{
      border:1px solid var(--line);
      border-radius: 14px;
      padding:10px;
      background: rgba(0,0,0,.16);
      position:relative;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.02);
    }
    .laneTitle{
      position:absolute;
      top:8px;
      left:10px;
      font-size:11px;
      color:rgba(255,255,255,.35);
      letter-spacing:.1em;
      text-transform:uppercase;
      user-select:none;
    }

    /* Slot matches card ratio */
    .slot{
      aspect-ratio: 2 / 3;
      width:100%;
      border:1px dashed rgba(255,255,255,.12);
      border-radius: 12px;
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
      overflow:hidden;
      margin-top:24px;
      cursor: default;
    }
    .slot + .slot{ margin-top:10px; }

    .slot.back[data-owner="player"]{
      cursor:pointer;
    }

    .slot.back::after{
      content:"BACK";
      position:absolute;
      bottom:8px;
      right:8px;
      font-size:10px;
      color:rgba(255,255,255,.24);
      letter-spacing:.10em;
      text-transform:uppercase;
      user-select:none;
    }
    .slot.front::after{
      content:"FRONT";
      position:absolute;
      bottom:8px;
      right:8px;
      font-size:10px;
      color:rgba(255,255,255,.24);
      letter-spacing:.10em;
      text-transform:uppercase;
      user-select:none;
    }

    .slot.placeable{
      outline:2px solid rgba(101,214,122,.35);
      box-shadow: 0 0 0 4px rgba(101,214,122,.08);
      border-style:solid;
    }
    .slot.blocked{
      outline:2px solid rgba(255,75,75,.25);
      box-shadow: 0 0 0 4px rgba(255,75,75,.06);
      border-style:solid;
    }

    .card{
      width:100%;
      height:100%;
      border-radius: 10px;
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
      background: rgba(0,0,0,.28);
      position:relative;
      box-shadow: 0 8px 20px rgba(0,0,0,.35);
      user-select:none;
      display:flex;
      align-items:stretch;
      justify-content:stretch;
    }

    .card img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      pointer-events:none;
    }

    .badge{
      position:absolute;
      top:8px;
      left:8px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.18);
      border-radius:999px;
      padding:4px 8px;
      font-size:11px;
      font-weight:1000;
      letter-spacing:.06em;
      color:#fff;
      backdrop-filter: blur(6px);
      user-select:none;
    }
    .badge.cost{ left:auto; right:8px; border-color: rgba(202,165,90,.35); color:#ffe9b5; }
    .badge.fd{ top:auto; bottom:8px; left:8px; border-color: rgba(255,255,255,.14); color: rgba(255,255,255,.85); }

    .damageFloat{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:1000;
      font-size:34px;
      color:#fff;
      text-shadow: 0 10px 20px rgba(0,0,0,.65);
      opacity:0;
      transform: translateY(8px);
      pointer-events:none;
    }
    .damageFloat.show{
      opacity:1;
      transform: translateY(0);
      transition: opacity .15s ease, transform .15s ease;
    }

    /* Right panel */
    .side{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--radius);
      padding:12px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }

    .side h2{
      margin:0 0 10px;
      font-size:13px;
      letter-spacing:.08em;
      text-transform:uppercase;
      color: rgba(255,255,255,.85);
    }

    .hand{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }

    .handCard{
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      overflow:hidden;
      background: rgba(0,0,0,.22);
      cursor:pointer;
      position:relative;
      box-shadow: 0 10px 22px rgba(0,0,0,.25);
    }
    .handCard:hover{filter:brightness(1.06)}
    .handCard.selected{
      outline:2px solid rgba(202,165,90,.45);
      box-shadow: 0 0 0 4px rgba(202,165,90,.12), 0 10px 22px rgba(0,0,0,.25);
    }
    .handCard img{
      width:100%;
      height:150px;
      object-fit:cover;
      display:block;
      pointer-events:none;
    }
    .handMeta{
      padding:8px 8px 10px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:8px;
    }
    .handMeta .nm{
      font-weight:1000;
      font-size:12px;
      line-height:1.1;
    }
    .handMeta .tiny{
      font-size:11px;
      color: var(--muted);
      line-height:1.1;
    }
    .handMeta .cost{
      font-weight:1000;
      color:#ffe9b5;
      background: rgba(202,165,90,.15);
      border:1px solid rgba(202,165,90,.30);
      padding:3px 7px;
      border-radius:999px;
      font-size:11px;
      white-space:nowrap;
      margin-top:1px;
    }

    .log{
      margin-top:12px;
      border-top:1px solid var(--line);
      padding-top:10px;
      max-height: 250px;
      overflow:auto;
      font-size:12px;
      color: var(--muted);
    }
    .log p{margin:0 0 6px}
    .log .good{color:rgba(101,214,122,.9)}
    .log .bad{color:rgba(255,75,75,.9)}
    .log .warn{color:rgba(255,209,102,.95)}

    .hint{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--muted);
      font-size:12px;
      line-height:1.35;
    }
    .hint b{color:var(--text)}

    .divider{height:1px; background:var(--line); margin:10px 0}

    .error{
      padding:12px;
      border-radius:12px;
      border:1px solid rgba(255,75,75,.35);
      background: rgba(255,75,75,.10);
      color:#ffd7d7;
      font-weight:800;
      margin-top:12px;
      line-height:1.35;
      white-space:pre-wrap;
    }

    .statusRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .statusRow .muted{color:var(--muted); font-size:12px}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title">
      <h1>Tankers</h1>
      <div class="sub">Face-down back row • flip + advance next turn • auto-fire</div>
    </div>

    <div class="topbar">
      <div class="pill"><span>Turn</span> <strong id="turnNum">1</strong></div>
      <div class="pill"><span>Your points</span> <strong id="pPts">1</strong></div>
      <div class="pill"><span>Opponent points</span> <strong id="oPts">1</strong></div>

      <select id="factionPick" title="Pick your faction">
        <option value="germany">Germany</option>
        <option value="allies">Allies</option>
      </select>

      <button class="btn" id="btnNew">New Game</button>
      <button class="btn primary" id="btnEnd" disabled>End Turn</button>
    </div>
  </header>

  <div class="gridShell">
    <div class="board">
      <div class="boardInner">
        <div class="hpbar">
          <div class="hpBox">
            <div class="who">You</div>
            <div class="hp good" id="pHP">20</div>
          </div>
          <div class="hpBox">
            <div class="who">Opponent</div>
            <div class="hp good" id="oHP">20</div>
          </div>
        </div>

        <div class="laneHints">
          <div>Opponent (top)</div>
          <div>Your Back Row is clickable (bottom)</div>
        </div>

        <div class="lanes" id="lanes"></div>
        <div id="err" class="error" style="display:none"></div>
      </div>
    </div>

    <aside class="side">
      <h2>Your Hand</h2>
      <div class="hand" id="hand"></div>

      <div class="statusRow">
        <div class="pill"><span>Selected</span> <strong id="selName">None</strong></div>
        <div class="muted" id="selHint">Click a card, then click an empty BACK slot.</div>
      </div>

      <div class="divider"></div>

      <div class="hint">
        <b>Rules:</b><br>
        • Place only on your <b>BACK row</b>. Cards are <b>face-down</b> (inactive) until your next turn.<br>
        • At the start of that player's next turn: back-row cards that have waited 1 turn <b>move to FRONT</b> (if open) and <b>flip revealed</b>.<br>
        • End Turn triggers your FRONT row to <b>auto-fire</b> down the lane. If no tank blocks: <b>base takes damage</b>.<br>
        • Points reset each turn to the current turn number (Turn 1 = 1 point, Turn 2 = 2 points, etc). Tier = cost.
      </div>

      <div class="log" id="log"></div>
    </aside>
  </div>
</div>

<script>
/* ===========================
   CONFIG
   =========================== */
const JSON_PATH = "tanks.json";
const CARD_BACK = "assets/img/card-back.png"; // must exist and load

const LANES = 4;
const PLAYER_MAX_HP = 20;
const START_HAND = 4;
const DRAW_PER_TURN = 1;

/* ===========================
   UTIL
   =========================== */
const $ = (s)=>document.querySelector(s);
const lanesEl = $("#lanes");
const handEl = $("#hand");
const logEl = $("#log");
const errEl = $("#err");
const btnEnd = $("#btnEnd");
const btnNew = $("#btnNew");
const factionPick = $("#factionPick");

const ui = {
  turn: $("#turnNum"),
  pPts: $("#pPts"),
  oPts: $("#oPts"),
  pHP: $("#pHP"),
  oHP: $("#oHP"),
  selName: $("#selName"),
  selHint: $("#selHint"),
};

let db = null;
let game = null;

function log(msg, cls=""){
  const p = document.createElement("p");
  p.textContent = msg;
  if (cls) p.className = cls;
  logEl.prepend(p);
}
function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}
function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }
function clampInt(n, a, b){ n = Math.floor(Number(n) || 0); return Math.max(a, Math.min(b, n)); }

function deriveTier(card){
  if (card.tier != null) return clampInt(card.tier, 1, 9);
  const s = card.stats || {};
  const score =
    (s.firepower || 0) * 1.2 +
    (s.armor || 0) * 1.0 +
    (s.hp || 0) * 0.5 +
    (s.mobility || 0) * 0.2 +
    (s.accuracy || 0) * 0.2 +
    (s.utility || 0) * 0.1;

  if (score <= 12) return 1;
  if (score <= 15) return 2;
  if (score <= 18) return 3;
  if (score <= 21) return 4;
  if (score <= 24) return 5;
  if (score <= 27) return 6;
  return 7;
}
function getCost(card){
  if (card.cost != null) return Math.max(1, Math.floor(card.cost));
  return deriveTier(card);
}

async function loadDB(){
  const res = await fetch(JSON_PATH, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status} ${res.statusText}`);
  const data = await res.json();
  if (!data || !Array.isArray(data.factions)) throw new Error(`Expected { "factions": [...] }`);
  return data;
}

function showError(text){
  errEl.style.display = "block";
  errEl.textContent =
`Could not load ${JSON_PATH}.

Fix checklist:
1) Make sure tanks.json is next to this HTML file.
2) Open via a local server (NOT file://). Example:
   - VSCode Live Server
   - python3 -m http.server

Details:
${text}`;
}
function hideError(){ errEl.style.display = "none"; errEl.textContent = ""; }

/* ===========================
   GAME MODEL
   =========================== */
// Each side has: back[LANES], front[LANES]
// CardState:
// { owner: "player"|"opponent", data, hp, faceDown, turnsInBack }
function makeCardState(card, owner){
  return {
    owner,
    data: card,
    hp: Number(card?.stats?.hp ?? 10),
    faceDown: true,        // ALWAYS face-down when played (inactive)
    turnsInBack: 0         // increments at start of owner's turns
  };
}

function visibleImageFor(cardState){
  // You (player) always see your own card faces.
  // Opponent back-row face-down cards show CARD_BACK until flipped.
  if (cardState.owner === "opponent" && cardState.faceDown) return CARD_BACK;
  return cardState.data.image;
}

function makeDeck(factionName){
  const f = db.factions.find(x => x.faction === factionName);
  const cards = (f?.cards || []).map(c => ({
    ...deepCopy(c),
    tier: c.tier ?? deriveTier(c),
    cost: c.cost ?? getCost(c),
  }));
  return shuffle(cards);
}

function drawToHand(side, n=1){
  for (let i=0;i<n;i++){
    if (side.deck.length === 0) return;
    side.hand.push(side.deck.pop());
  }
}

function pickFactions(playerFaction){
  const all = db.factions.map(f=>f.faction);
  if (!all.includes(playerFaction)) playerFaction = all[0];
  const oppFaction = all.find(x => x !== playerFaction) || playerFaction;
  return { playerFaction, oppFaction };
}

/* ===========================
   UI BUILD
   =========================== */
function buildBoardUI(){
  lanesEl.innerHTML = "";
  for (let lane=0; lane<LANES; lane++){
    const laneEl = document.createElement("div");
    laneEl.className = "lane";
    laneEl.dataset.lane = lane;
    laneEl.innerHTML = `
      <div class="laneTitle">Lane ${lane+1}</div>

      <div class="slot front" data-owner="opponent" data-row="front" data-lane="${lane}"></div>
      <div class="slot back"  data-owner="opponent" data-row="back"  data-lane="${lane}"></div>

      <div class="slot front" data-owner="player" data-row="front" data-lane="${lane}"></div>
      <div class="slot back"  data-owner="player" data-row="back"  data-lane="${lane}"></div>
    `;
    lanesEl.appendChild(laneEl);
  }

  lanesEl.addEventListener("click", (e)=>{
    const slot = e.target.closest(".slot");
    if (!slot) return;
    if (!game) return;

    const owner = slot.dataset.owner;
    const row = slot.dataset.row;
    const lane = Number(slot.dataset.lane);

    // Only player can place; only on player back row; only during player turn
    if (game.active !== "player") return;
    if (owner !== "player" || row !== "back") return;

    placeSelectedIntoLane(lane);
  });
}

/* ===========================
   SELECTION / PLACEMENT
   =========================== */
function selectHand(idx){
  game.selectedHandIndex = idx;
  renderHand();
}
function clearSelection(){
  game.selectedHandIndex = null;
  renderHand();
}

function placeSelectedIntoLane(lane){
  const idx = game.selectedHandIndex;
  if (idx == null){
    ui.selHint.textContent = "Select a card first.";
    return;
  }
  const card = game.player.hand[idx];
  if (!card) return;

  const cost = getCost(card);
  if (cost > game.player.points){
    ui.selHint.textContent = `Not enough points. Need ${cost}, you have ${game.player.points}.`;
    renderAll();
    return;
  }
  if (game.player.back[lane] !== null){
    ui.selHint.textContent = "That BACK slot is occupied.";
    renderAll();
    return;
  }

  game.player.points -= cost;
  game.player.hand.splice(idx, 1);
  game.selectedHandIndex = null;

  // Always faceDown on back row. (Player sees their art, but it's still inactive.)
  game.player.back[lane] = makeCardState(card, "player");

  log(`You deploy ${card.name} to BACK row (Lane ${lane+1}). It will flip + advance next turn.`, "good");
  ui.selHint.textContent = "Placed. End Turn when ready.";

  renderAll();
}

/* ===========================
   TURN FLOW
   =========================== */
function startTurn(sideName){
  game.active = sideName;

  // points reset to turn number
  const side = sideName === "player" ? game.player : game.opp;
  side.points = game.turn;

  // increment wait counter for back-row units, then promote eligible ones
  progressBackRow(sideName);

  // draw
  drawToHand(side, DRAW_PER_TURN);

  if (sideName === "player"){
    log(`Your turn ${game.turn}. Points: ${side.points}.`, "warn");
    ui.selHint.textContent = "Click a card, then click an empty BACK slot.";
  } else {
    log(`Opponent turn ${game.turn}.`, "warn");
    ui.selHint.textContent = "Opponent is acting…";
  }

  renderAll();
}

function progressBackRow(sideName){
  const side = sideName === "player" ? game.player : game.opp;

  for (let lane=0; lane<LANES; lane++){
    const backCard = side.back[lane];
    if (!backCard) continue;

    backCard.turnsInBack += 1;

    // Must wait exactly 1 full turn in back row:
    // placed on turn T => at start of turn T+1, turnsInBack becomes 1 => still waiting.
    // at start of turn T+2, turnsInBack becomes 2 => eligible to advance/flip.
    if (backCard.turnsInBack < 2) continue;

    if (side.front[lane] === null){
      side.front[lane] = backCard;
      side.back[lane] = null;

      // flip revealed (active)
      backCard.faceDown = false;

      if (sideName === "player"){
        log(`${backCard.data.name} advances to FRONT and flips revealed (Lane ${lane+1}).`, "good");
      } else {
        log(`Opponent tank advances to FRONT and flips revealed (Lane ${lane+1}).`, "bad");
      }
    }
  }
}

function resolveAttacks(attackerSideName){
  const A = attackerSideName === "player" ? game.player : game.opp;
  const D = attackerSideName === "player" ? game.opp : game.player;

  for (let lane=0; lane<LANES; lane++){
    const atk = A.front[lane];
    if (!atk) continue;

    // Only revealed/active units can attack.
    if (atk.faceDown) continue;

    const fp = Number(atk.data?.stats?.firepower ?? 0);
    if (fp <= 0) continue;

    const def = D.front[lane];
    if (def){
      const armor = Number(def.data?.stats?.armor ?? 0);
      const dmg = Math.max(1, fp - Math.floor(armor/2));
      def.hp -= dmg;

      floatDamage(attackerSideName === "player" ? "opponent" : "player", "front", lane, `-${dmg}`);

      log(`${atk.data.name} hits ${def.data.name} (Lane ${lane+1}) for ${dmg}.`, attackerSideName === "player" ? "good" : "bad");

      if (def.hp <= 0){
        log(`${def.data.name} is destroyed!`, "warn");
        D.front[lane] = null;
      }
    } else {
      D.hp -= fp;
      log(`${atk.data.name} fires down Lane ${lane+1} and hits the ${attackerSideName === "player" ? "opponent" : "player"} for ${fp}.`, attackerSideName === "player" ? "good" : "bad");
    }

    if (D.hp <= 0) break;
  }

  renderAll();
}

function checkGameOver(){
  if (game.player.hp <= 0){
    log("You lose.", "bad");
    btnEnd.disabled = true;
    return true;
  }
  if (game.opp.hp <= 0){
    log("You win!", "good");
    btnEnd.disabled = true;
    return true;
  }
  return false;
}

/* ===========================
   OPPONENT AI
   =========================== */
function opponentPlay(){
  const opp = game.opp;

  // spend points, highest cost first, place only on BACK row
  const laneOrder = shuffle([...Array(LANES).keys()]);
  const sorted = opp.hand.slice().sort((a,b)=>getCost(b)-getCost(a));

  for (const card of sorted){
    const cost = getCost(card);
    if (cost > opp.points) continue;

    const lane = laneOrder.find(L => opp.back[L] === null);
    if (lane === undefined) break;

    // remove from hand
    const idx = opp.hand.findIndex(x => x.id === card.id);
    if (idx >= 0) opp.hand.splice(idx,1);

    opp.points -= cost;

    // Always faceDown on back row and hidden to player visually via CARD_BACK until flip
    opp.back[lane] = makeCardState(card, "opponent");

    log(`Opponent deploys a tank to BACK row (Lane ${lane+1}) face-down.`, "bad");
  }

  renderAll();
}

/* ===========================
   RENDER
   =========================== */
function renderAll(){
  if (!game) return;

  ui.turn.textContent = String(game.turn);
  ui.pPts.textContent = String(game.player.points);
  ui.oPts.textContent = String(game.opp.points);

  ui.pHP.textContent = String(game.player.hp);
  ui.oHP.textContent = String(game.opp.hp);

  ui.pHP.className = "hp " + (game.player.hp >= 11 ? "good" : "bad");
  ui.oHP.className = "hp " + (game.opp.hp >= 11 ? "good" : "bad");

  renderBoard();
  renderHand();

  const sel = (game.selectedHandIndex != null) ? game.player.hand[game.selectedHandIndex] : null;
  ui.selName.textContent = sel ? sel.name : "None";

  btnEnd.disabled = !game || game.active !== "player";
}

function renderBoard(){
  const slots = lanesEl.querySelectorAll(".slot");
  const hasSelected = (game.active === "player" && game.selectedHandIndex != null);

  slots.forEach(slot=>{
    const owner = slot.dataset.owner;
    const row = slot.dataset.row;
    const lane = Number(slot.dataset.lane);

    const side = owner === "player" ? game.player : game.opp;
    const cardState = (row === "front") ? side.front[lane] : side.back[lane];

    slot.innerHTML = "";

    // highlight placeable back slots
    slot.classList.remove("placeable","blocked");
    if (hasSelected && owner === "player" && row === "back"){
      if (side.back[lane] === null) slot.classList.add("placeable");
      else slot.classList.add("blocked");
    }

    if (!cardState) return;

    const cardEl = document.createElement("div");
    cardEl.className = "card";

    const img = document.createElement("img");
    img.src = visibleImageFor(cardState);
    img.alt = cardState.data.name;
    img.onerror = () => { img.src = CARD_BACK; };
    cardEl.appendChild(img);

    const cost = getCost(cardState.data);
    const tier = deriveTier(cardState.data);

    const hpB = document.createElement("div");
    hpB.className = "badge";
    hpB.textContent = `HP ${cardState.hp}`;
    cardEl.appendChild(hpB);

    const costB = document.createElement("div");
    costB.className = "badge cost";
    costB.textContent = `T${tier} • ${cost}`;
    cardEl.appendChild(costB);

    // show "FACE DOWN" badge on any back-row inactive card (optional)
    if (cardState.faceDown){
      const fd = document.createElement("div");
      fd.className = "badge fd";
      fd.textContent = "FACE DOWN";
      cardEl.appendChild(fd);
    }

    const dmg = document.createElement("div");
    dmg.className = "damageFloat";
    dmg.textContent = "";
    cardEl.appendChild(dmg);

    slot.appendChild(cardEl);
  });
}

function renderHand(){
  handEl.innerHTML = "";
  if (!game) return;

  const hand = game.player.hand;
  if (hand.length === 0){
    const empty = document.createElement("div");
    empty.style.gridColumn = "1 / -1";
    empty.className = "hint";
    empty.innerHTML = `<b>No cards in hand.</b><br>End turns to draw more.`;
    handEl.appendChild(empty);
    return;
  }

  hand.forEach((card, idx)=>{
    const el = document.createElement("div");
    el.className = "handCard" + (game.selectedHandIndex === idx ? " selected" : "");
    el.addEventListener("click", ()=>{
      if (!game || game.active !== "player") return;
      if (game.selectedHandIndex === idx) clearSelection();
      else selectHand(idx);
    });

    const cost = getCost(card);
    const tier = deriveTier(card);

    el.innerHTML = `
      <img src="${card.image}" alt="${card.name}" draggable="false">
      <div class="handMeta">
        <div>
          <div class="nm">${card.name}</div>
          <div class="tiny">T${tier} • FP ${card.stats.firepower} • AR ${card.stats.armor}</div>
        </div>
        <div class="cost">${cost}</div>
      </div>
    `;

    if (game.active !== "player" || cost > game.player.points){
      el.style.opacity = "0.6";
    }

    handEl.appendChild(el);
  });
}

function floatDamage(owner, row, lane, text){
  const slot = document.querySelector(`.slot[data-owner="${owner}"][data-row="${row}"][data-lane="${lane}"]`);
  if (!slot) return;
  const dmg = slot.querySelector(".damageFloat");
  if (!dmg) return;
  dmg.textContent = text;
  dmg.classList.add("show");
  setTimeout(()=>dmg.classList.remove("show"), 420);
}

/* ===========================
   GAME START / BUTTONS
   =========================== */
function newGame(){
  hideError();
  logEl.innerHTML = "";

  const { playerFaction, oppFaction } = pickFactions(factionPick.value);

  const player = {
    faction: playerFaction,
    hp: PLAYER_MAX_HP,
    points: 1,
    deck: makeDeck(playerFaction),
    hand: [],
    back: Array(LANES).fill(null),
    front: Array(LANES).fill(null),
  };
  const opp = {
    faction: oppFaction,
    hp: PLAYER_MAX_HP,
    points: 1,
    deck: makeDeck(oppFaction),
    hand: [],
    back: Array(LANES).fill(null),
    front: Array(LANES).fill(null),
  };

  game = {
    turn: 1,
    active: "player",
    player,
    opp,
    selectedHandIndex: null,
  };

  drawToHand(player, START_HAND);
  drawToHand(opp, START_HAND);

  buildBoardUI();
  renderAll();

  btnEnd.disabled = false;

  log(`New game: YOU = ${playerFaction.toUpperCase()} vs OPPONENT = ${oppFaction.toUpperCase()}.`, "good");
  log(`Turn 1: You have 1 point. Place a tank on your BACK row.`, "warn");
}

btnNew.addEventListener("click", newGame);

btnEnd.addEventListener("click", ()=>{
  if (!game || game.active !== "player") return;

  // Player end-turn attack
  resolveAttacks("player");
  if (checkGameOver()) return;

  // Opponent turn start
  startTurn("opponent");

  // Opponent plays (back row, face down)
  opponentPlay();

  // Opponent end-turn attack
  resolveAttacks("opponent");
  if (checkGameOver()) return;

  // Next turn
  game.turn += 1;
  startTurn("player");
});

(async function init(){
  // preload card back
  const pre = new Image();
  pre.src = CARD_BACK;

  try{
    db = await loadDB();
    log(`Loaded ${db.factions.length} faction(s) from ${JSON_PATH}.`, "good");
    newGame();
  }catch(e){
    showError(String(e && e.message ? e.message : e));
  }
})();
</script>
</body>
</html>
