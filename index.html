<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>freshfrogs.github.io</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="../style.css" />

  <!-- Frog background canvas styles -->
  <style>
    #frog-bg {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      background: #7cc1ff;
      overflow: hidden;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      pointer-events: none; /* let user interact with the site */
    }
    .page {
      position: relative;
      z-index: 1;
    }
    .frog-sprite {
      position: absolute;
      width: 64px;
      height: 64px;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      pointer-events: none;
    }
    .frog-sprite img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      image-rendering: inherit;
    }

  </style>
</head>
<body class="layout-4">
  <!-- Random trait-built frogs background -->
  <div id="frog-bg"></div>

  <div class="page">
    <!-- HEADER -->
    <header class="site-header">
      <nav class="nav">
        <a href="/" data-view="collection">Collection</a>
        <a href="/rarity/" data-view="rarity">Rarity</a>
        <a href="/pond/" data-view="pond">Pond</a>
        <a href="/morph/" data-view="morph">Morph</a>

        <a href="#" id="header-connect-wallet-btn">Connect</a>
        <a href="#" data-view="wallet" id="wallet-nav-link" style="display:none;"></a>
      </nav>
    </header>

    <!-- DASHBOARD HERO -->
    <section class="hero">
      <div class="hero-main">
        <div class="hero-media">
          <img src="https://freshfrogs.github.io/frog/16.png" class="fly" />
          <img src="https://freshfrogs.github.io/frog/3753.png" class="fly" />
          <img src="https://freshfrogs.github.io/frog/467.png" class="fly" />
          <img src="https://freshfrogs.github.io/frog/594.png" class="fly" />
        </div>
        <h1 class="hero-title">freshfrogs.github.io</h1>
        <p class="hero-subtitle">
          A collection of 4,040 randomly generated frogs on the Ethereum
          blockchain, that are each unique with thousands of different
          combinations!
          Stake and earn rewards, level up, unlock custom trait animations and
          more! All secondary sales are entitled to a <b>5%</b> royalty.
        </p>
      </div>
    </section>

    <!-- MAIN DASHBOARD LAYOUT -->
    <main class="dashboard-main">
      <!-- Recent Activity (sales / mints) -->
      <section
        class="panel dashboard-section"
        id="recent-activity-panel"
        style="background: transparent; box-shadow: none; padding: 0;"
      >
        <h2>Recent Activity</h2>
        <p class="dashboard-note" id="recent-sales-status">
          Loading recent sales...
        </p>

        <div class="recent_sales" id="recent-sales"></div>

        <button id="load-more-activity" class="btn secondary" type="button">
          Load More
        </button>
      </section>

      <!-- Rarity Rankings -->
      <section
        class="panel dashboard-section"
        id="rarity-panel"
        style="display:none; background: transparent; box-shadow: none; padding: 0;"
      >
        <h2>Rarity Rankings</h2>
        <p class="dashboard-note" id="rarity-status">
          Top ranked Frogs across the collection (lower rank = rarer).
        </p>

        <div id="rarity-grid" class="recent_sales"></div>

        <button id="load-more-rarity" class="btn secondary" type="button">
          Load More
        </button>
      </section>

      <!-- Pond -->
      <section
        class="panel dashboard-section"
        id="pond-panel"
        style="display:none; background: transparent; box-shadow: none; padding: 0;"
      >
        <h2>The Pond</h2>
        <p class="dashboard-note" id="pond-status">
          All Frogs currently staked by the community.
        </p>

        <div id="pond-grid" class="recent_sales"></div>

        <button id="load-more-pond" class="btn secondary" type="button">
          Load More
        </button>

        <h3>Recent Morphs</h3>
        <p class="dashboard-note" id="recent-morphs-status">
          Loading recent morphs...
        </p>

        <div id="recent-morphs-grid" class="recent_sales"></div>
      </section>

      <!-- Owned Frogs -->
      <section
        class="panel dashboard-section"
        id="owned-panel"
        style="display:none; background: transparent; box-shadow: none; padding: 0;"
      >
        <h2>Owned Frogs</h2>
        <p class="dashboard-note" id="owned-frogs-status">
          These are Frogs currently held in your wallet.
        </p>

        <div id="owned-frogs-grid" class="nft-grid"></div>
      </section>

      <!-- Staked Frogs -->
      <section
        class="panel dashboard-section"
        id="staked-panel"
        style="display:none; background: transparent; box-shadow: none; padding: 0;"
      >
        <h2>Staked Frogs</h2>
        <p class="dashboard-note" id="staked-frogs-status">
          These Frogs are staked in the FreshFrogs controller.
        </p>

        <div id="staked-frogs-grid" class="nft-grid"></div>
      </section>
    </main>

    <!-- FOOTER -->
    <footer class="site-footer">
      <span class="footer-links" style="color: white;">
        <a href="#">freshfrogs.github.io</a>
      </span>
    </footer>
  </div>

  <!-- Web3 for wallet / staking functions -->
  <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>

  <!-- ABIs + legacy staking helpers -->
  <script src="https://freshfrogs.github.io/assets/collection_abi.js"></script>
  <script src="https://freshfrogs.github.io/assets/controller_abi.js"></script>
  <script src="https://freshfrogs.github.io/assets/ethereum-dapp.js"></script>

  <!-- Rarity rankings (must load before site.js) -->
  <script src="https://freshfrogs.github.io/assets/rarityrankings.js"></script>

  <!-- Frog background logic (wrapped to avoid globals) -->
<script>
  (function () {
    const FROG_SIZE = 64;
    const container = document.getElementById("frog-bg");
    if (!container) return;

    let frogs = [];
    let animId = null;
    let lastTime = 0;

    // Where frogs drift after you click
    const target = {
      x: window.innerWidth / 2,
      y: window.innerHeight / 2,
      active: false
    };

    // Click: set target + make nearest frog hop
    window.addEventListener("click", (e) => {
      const clickX = e.clientX;
      const clickY = e.clientY;

      target.x = clickX;
      target.y = clickY;
      target.active = true;

      let nearest = null;
      let nearestDist2 = Infinity;

      for (const frog of frogs) {
        const cx = frog.x + FROG_SIZE / 2;
        const cy = frog.y + FROG_SIZE / 2;
        const dx = clickX - cx;
        const dy = clickY - cy;
        const d2 = dx * dx + dy * dy;
        if (d2 < nearestDist2) {
          nearestDist2 = d2;
          nearest = frog;
        }
      }

      const MAX_CLICK_RADIUS = 120;
      if (nearest && nearestDist2 <= MAX_CLICK_RADIUS * MAX_CLICK_RADIUS) {
        nearest.state = "hopping";
        nearest.hopTime = 0;
        nearest.hopDuration = randRange(nearest.hopDurMin * 0.6, nearest.hopDurMax * 0.9);
        nearest.hopHeight = randRange(nearest.hopHeightMax * 1.1, nearest.hopHeightMax * 1.7);
      }
    });

    // ----------------- helpers -----------------
    function randInt(min, maxInclusive) {
      return Math.floor(Math.random() * (maxInclusive - min + 1)) + min;
    }

    function randRange(min, max) {
      return min + Math.random() * (max - min);
    }

    function computeFrogPositions(width, height, maxCountOverride) {
      const area = width * height;
      const maxFrogs = typeof maxCountOverride === "number"
        ? maxCountOverride
        : 120;

      const approxPerFrogArea = (FROG_SIZE * FROG_SIZE) * 5;
      let targetCount = Math.floor(area / approxPerFrogArea);
      targetCount = Math.max(15, Math.min(maxFrogs, targetCount));

      const positions = [];
      const MIN_DIST = 52;
      const margin = 16;

      let safety = targetCount * 50;
      while (positions.length < targetCount && safety-- > 0) {
        const x = margin + Math.random() * (width - margin * 2 - FROG_SIZE);
        const y = margin + Math.random() * (height - margin * 2 - FROG_SIZE);
        const cx = x + FROG_SIZE / 2;
        const cy = y + FROG_SIZE / 2;

        let ok = true;
        for (const p of positions) {
          const pcx = p.x + FROG_SIZE / 2;
          const pcy = p.y + FROG_SIZE / 2;
          const dx = cx - pcx;
          const dy = cy - pcy;
          if (dx * dx + dy * dy < MIN_DIST * MIN_DIST) {
            ok = false;
            break;
          }
        }
        if (ok) positions.push({ x, y });
      }
      return positions;
    }

    async function fetchMorphedMetadata(limit) {
      try {
        if (typeof window.ffFetchRecentMorphedFrogs === "function") {
          // this hits your morph worker via the function from site.js
          return await window.ffFetchRecentMorphedFrogs(limit);
        }
      } catch (err) {
        console.warn("fetchMorphedMetadata failed:", err);
      }
      return [];
    }

    function getMorphImageUrl(meta) {
      if (!meta || typeof meta !== "object") return null;
      return (
        meta.image ||
        meta.image_url ||
        meta.morphedImage ||
        meta.animation_url ||
        null
      );
    }

    async function createFrogs(width, height) {
      frogs = [];
      container.innerHTML = "";

      // pull a bunch of morphed frogs (newest first)
      const morphMetas = await fetchMorphedMetadata(300);
      if (!morphMetas.length) {
        console.warn("No morphed frogs returned for scatter background.");
        return;
      }

      // limit displayed frogs for performance / clutter
      const maxScatter = Math.min(morphMetas.length, 150);
      const positions = computeFrogPositions(width, height, maxScatter);
      const count = Math.min(positions.length, morphMetas.length);

      for (let i = 0; i < count; i++) {
        const pos = positions[i];
        const meta = morphMetas[i];

        const src = getMorphImageUrl(meta);
        if (!src) continue;

        const el = document.createElement("div");
        el.className = "frog-sprite";
        el.style.transform = `translate3d(${pos.x}px, ${pos.y}px, 0)`;

        const img = document.createElement("img");
        img.src = src;                 // can be GIF â†’ will animate naturally
        img.alt = meta.name || "";
        el.appendChild(img);

        container.appendChild(el);

        const personalityRoll = Math.random();
        let idleMin, idleMax, hopMin, hopMax, heightMin, heightMax, vxRange;

        if (personalityRoll < 0.25) {
          // hyper
          idleMin = 0.3; idleMax = 1.0;
          hopMin = 0.25; hopMax = 0.55;
          heightMin = 14; heightMax = 32;
          vxRange = 20;
        } else if (personalityRoll < 0.6) {
          // normal
          idleMin = 0.8; idleMax = 3.0;
          hopMin = 0.35; hopMax = 0.7;
          heightMin = 10; heightMax = 26;
          vxRange = 12;
        } else {
          // lazy
          idleMin = 2.0; idleMax = 5.0;
          hopMin = 0.45; hopMax = 0.9;
          heightMin = 6;  heightMax = 20;
          vxRange = 8;
        }

        frogs.push({
          meta,
          el,
          x: pos.x,
          y: pos.y,
          baseY: pos.y,
          vx: randRange(-vxRange, vxRange),
          seekFactorX: randRange(0.05, 0.15),
          seekFactorY: randRange(0.03, 0.08),

          state: "idle",
          idleTime: randRange(idleMin, idleMax),
          hopTime: 0,
          hopDuration: randRange(hopMin, hopMax),
          hopHeight: randRange(heightMin, heightMax),

          idleMin, idleMax,
          hopDurMin: hopMin,
          hopDurMax: hopMax,
          hopHeightMin: heightMin,
          hopHeightMax: heightMax
        });
      }
    }

    // ----------------- animation -----------------
    function updateFrogs(dt, width, height) {
      for (const frog of frogs) {
        const centerX = frog.x + FROG_SIZE / 2;
        const centerBaseY = frog.baseY + FROG_SIZE / 2;

        // Drift toward last click target
        if (target.active) {
          const dx = target.x - centerX;
          const dy = target.y - centerBaseY;
          frog.x     += dx * frog.seekFactorX * dt;
          frog.baseY += dy * frog.seekFactorY * dt;
        }

        // small sideways drift
        frog.x += frog.vx * dt * 0.3;
        if (frog.x < -FROG_SIZE * 0.25) {
          frog.x = -FROG_SIZE * 0.25;
          frog.vx *= -1;
        } else if (frog.x > width - FROG_SIZE * 0.75) {
          frog.x = width - FROG_SIZE * 0.75;
          frog.vx *= -1;
        }

        // clamp vertical
        const marginY = 24;
        frog.baseY = Math.max(
          marginY,
          Math.min(height - marginY - FROG_SIZE, frog.baseY)
        );

        // idle / hopping behavior
        if (frog.state === "idle") {
          frog.idleTime -= dt;
          frog.y = frog.baseY;

          if (frog.idleTime <= 0) {
            frog.state = "hopping";
            frog.hopTime = 0;
            frog.hopDuration = randRange(frog.hopDurMin, frog.hopDurMax);

            const spice = Math.random();
            if (spice < 0.1) {
              frog.hopHeight = randRange(frog.hopHeightMax * 1.1, frog.hopHeightMax * 1.8);
            } else if (spice < 0.25) {
              frog.hopHeight = randRange(2, frog.hopHeightMin * 0.7);
            } else {
              frog.hopHeight = randRange(frog.hopHeightMin, frog.hopHeightMax);
            }
          }
        } else if (frog.state === "hopping") {
          frog.hopTime += dt;
          const t = Math.min(1, frog.hopTime / frog.hopDuration);

          const offset = -4 * frog.hopHeight * t * (1 - t);
          frog.y = frog.baseY + offset;

          if (frog.hopTime >= frog.hopDuration) {
            frog.state = "idle";
            frog.idleTime = randRange(frog.idleMin, frog.idleMax);
            frog.y = frog.baseY;
          }
        }

        // apply transform to DOM element
        frog.el.style.transform = `translate3d(${frog.x}px, ${frog.y}px, 0)`;
      }
    }

    function drawFrame(time) {
      const width = window.innerWidth;
      const height = window.innerHeight;

      if (!lastTime) lastTime = time;
      const dt = (time - lastTime) / 1000;
      lastTime = time;

      updateFrogs(dt, width, height);
      animId = requestAnimationFrame(drawFrame);
    }

    async function resetAndStart() {
      const width = window.innerWidth;
      const height = window.innerHeight;

      if (animId) {
        cancelAnimationFrame(animId);
        animId = null;
      }
      lastTime = 0;

      await createFrogs(width, height);
      animId = requestAnimationFrame(drawFrame);
    }

    window.addEventListener("resize", resetAndStart);
    window.addEventListener("load", resetAndStart);
  })();
</script>

  <!-- Main site logic (recent activity, wallet, dashboard, etc.) -->
<script src="/assets/site.js"></script>
</body>
</html>
