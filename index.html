<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>freshfrogs.github.io</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="../style.css" />

  <!-- Frog background canvas styles -->
  <style>
    #frog-bg {
      position: fixed;
      inset: 0;
      z-index: -1;
      background: #bfe8ff; /* light blue */
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
  </style>
</head>
<body class="layout-4">
  <!-- Random trait-built frogs background -->
  <canvas id="frog-bg"></canvas>

  <div class="page">
    <!-- HEADER -->
    <header class="site-header">
      <nav class="nav">
        <a href="/" data-view="collection">Collection</a>
        <a href="/rarity/" data-view="rarity">Rarity</a>
        <a href="/pond/" data-view="pond">Pond</a>
        <a href="/morph/" data-view="morph">Morph</a>

        <a href="#" id="header-connect-wallet-btn">Connect</a>
        <a href="#" data-view="wallet" id="wallet-nav-link" style="display:none;"></a>
      </nav>
    </header>

    <!-- DASHBOARD HERO -->
    <section class="hero">
      <div class="hero-main">
        <div class="hero-media">
          <img src="https://freshfrogs.github.io/frog/16.png" class="fly" />
          <img src="https://freshfrogs.github.io/frog/3753.png" class="fly" />
          <img src="https://freshfrogs.github.io/frog/467.png" class="fly" />
          <img src="https://freshfrogs.github.io/frog/594.png" class="fly" />
        </div>
        <h1 class="hero-title">freshfrogs.github.io</h1>
        <p class="hero-subtitle">
          A collection of 4,040 randomly generated frogs on the Ethereum
          blockchain, that are each unique with thousands of different
          combinations!
          Stake and earn rewards, level up, unlock custom trait animations and
          more! All secondary sales are entitled to a <b>5%</b> royalty.
        </p>
      </div>
    </section>

    <!-- MAIN DASHBOARD LAYOUT -->
    <main class="dashboard-main">
      <!-- Recent Activity (sales / mints) -->
      <section
        class="panel dashboard-section"
        id="recent-activity-panel"
        style="background: transparent; box-shadow: none; padding: 0;"
      >
        <h2>Recent Activity</h2>
        <p class="dashboard-note" id="recent-sales-status">
          Loading recent sales...
        </p>

        <div class="recent_sales" id="recent-sales"></div>

        <button id="load-more-activity" class="btn secondary" type="button">
          Load More
        </button>
      </section>

      <!-- Rarity Rankings -->
      <section
        class="panel dashboard-section"
        id="rarity-panel"
        style="display:none; background: transparent; box-shadow: none; padding: 0;"
      >
        <h2>Rarity Rankings</h2>
        <p class="dashboard-note" id="rarity-status">
          Top ranked Frogs across the collection (lower rank = rarer).
        </p>

        <div id="rarity-grid" class="recent_sales"></div>

        <button id="load-more-rarity" class="btn secondary" type="button">
          Load More
        </button>
      </section>

      <!-- Pond -->
      <section
        class="panel dashboard-section"
        id="pond-panel"
        style="display:none; background: transparent; box-shadow: none; padding: 0;"
      >
        <h2>The Pond</h2>
        <p class="dashboard-note" id="pond-status">
          All Frogs currently staked by the community.
        </p>

        <div id="pond-grid" class="recent_sales"></div>

        <button id="load-more-pond" class="btn secondary" type="button">
          Load More
        </button>

        <h3>Recent Morphs</h3>
        <p class="dashboard-note" id="recent-morphs-status">
          Loading recent morphs...
        </p>

        <div id="recent-morphs-grid" class="recent_sales"></div>
      </section>

      <!-- Owned Frogs -->
      <section
        class="panel dashboard-section"
        id="owned-panel"
        style="display:none; background: transparent; box-shadow: none; padding: 0;"
      >
        <h2>Owned Frogs</h2>
        <p class="dashboard-note" id="owned-frogs-status">
          These are Frogs currently held in your wallet.
        </p>

        <div id="owned-frogs-grid" class="nft-grid"></div>
      </section>

      <!-- Staked Frogs -->
      <section
        class="panel dashboard-section"
        id="staked-panel"
        style="display:none; background: transparent; box-shadow: none; padding: 0;"
      >
        <h2>Staked Frogs</h2>
        <p class="dashboard-note" id="staked-frogs-status">
          These Frogs are staked in the FreshFrogs controller.
        </p>

        <div id="staked-frogs-grid" class="nft-grid"></div>
      </section>
    </main>

    <!-- FOOTER -->
    <footer class="site-footer">
      <span class="footer-links" style="color: white;">
        <a href="#">freshfrogs.github.io</a>
      </span>
    </footer>
  </div>

  <!-- Web3 for wallet / staking functions -->
  <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>

  <!-- ABIs + legacy staking helpers -->
  <script src="https://freshfrogs.github.io/assets/collection_abi.js"></script>
  <script src="https://freshfrogs.github.io/assets/controller_abi.js"></script>
  <script src="https://freshfrogs.github.io/assets/ethereum-dapp.js"></script>

  <!-- Rarity rankings (must load before site.js) -->
  <script src="https://freshfrogs.github.io/assets/rarityrankings.js"></script>

  <!-- Frog background logic (wrapped to avoid globals) -->
<script>
  (function () {
    const FROG_SIZE    = 64;
    const MAX_TOKEN_ID = 4040;
    const META_BASE    = "/frog/json/";
    const META_EXT     = ".json";
    const BUILD_BASE   = "/frog/build_files";
    const ANIMATED_VALUES = new Set([
  'witchStraw',
  'witchBrown',
  'witchBlack',
  'goldenDartFrog',
  'blueDartFrog',
  'blueTreeFrog',
  'brownTreeFrog',
  'redEyedTreeFrog',
  'tongueSpiderRed',
  'tongueSpider',
  'tongue',
  'tongueFly',
  'croaking',
  'peace',
  'inversedEyes',
  'closedEyes',
  'thirdEye',
  'mask',
  'smoking',
  'smokingCigar',
  'smokingPipe',
  'circleShadesRed',
  'circleShadesPurple',
  'shades',
  'shadesPurple',
  'shadesThreeD',
  'shadesWhite',
  'circleNightVision',
  'baseballCapBlue',
  'baseballCapRed',
  'baseballCapWhite',
  'yellow',
  'blue(2)',
  'blue',
  'cyan',
  'brown',
  'silverEthChain',
  'goldDollarChain',
  'treeFrog(4)'
]);


    const canvas = document.getElementById("frog-bg");
    if (!canvas || !canvas.getContext) return;
    const ctx = canvas.getContext("2d", { alpha: false });

    let frogs = [];
    let animId = null;
    let lastTime = 0;

    // ----------------- helpers -----------------
    function randInt(min, maxInclusive) {
      return Math.floor(Math.random() * (maxInclusive - min + 1)) + min;
    }

    function randRange(min, max) {
      return min + Math.random() * (max - min);
    }

    function pickRandomTokenIds(count) {
      const set = new Set();
      while (set.size < count) {
        set.add(randInt(1, MAX_TOKEN_ID));
      }
      return Array.from(set);
    }

    function loadImage(url) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.decoding = "async";
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error("Failed to load " + url));
        img.src = url;
      });
    }

    async function fetchMetadata(tokenId) {
      const url = META_BASE + tokenId + META_EXT;
      const res = await fetch(url);
      if (!res.ok) throw new Error("Metadata fetch failed for " + tokenId);
      return res.json();
    }

    async function loadLayerImage(traitType, value) {
      const v = String(value); // make sure it's a string
      const pngUrl  = `${BUILD_BASE}/${traitType}/${v}.png`;

      // Only try GIF if this value is in the animated list
      if (ANIMATED_VALUES.has(v)) {
        const animUrl = `${BUILD_BASE}/${traitType}/animations/${v}_animation.gif`;
        try {
          return await loadImage(animUrl);
        } catch (e) {
          // fall through to PNG if GIF missing/broken
        }
      }

      try {
        return await loadImage(pngUrl);
      } catch (e) {
        // non-visual trait or missing asset
        return null;
      }
    }


    // Build ordered layers for a frog
    async function buildLayersFromMetadata(meta) {
      const layers = [];
      if (!Array.isArray(meta.attributes)) return layers;

      for (const attr of meta.attributes) {
        if (!attr.trait_type || typeof attr.value === "undefined") continue;
        const img = await loadLayerImage(attr.trait_type, attr.value);
        if (!img) continue;
        layers.push({ img, traitType: attr.trait_type, value: attr.value });
      }

      return layers;
    }

    // ----------------- layout + frog creation -----------------
    function computeFrogPositions(width, height) {
      const area = width * height;
      const maxFrogs = 120;
      const approxPerFrogArea = (FROG_SIZE * FROG_SIZE) * 5;
      let targetCount = Math.floor(area / approxPerFrogArea);
      targetCount = Math.max(15, Math.min(maxFrogs, targetCount));

      const positions = [];
      const MIN_DIST = 52; // center-to-center
      const margin = 16;

      let safety = targetCount * 50;
      while (positions.length < targetCount && safety-- > 0) {
        const x = margin + Math.random() * (width - margin * 2 - FROG_SIZE);
        const y = margin + Math.random() * (height - margin * 2 - FROG_SIZE);
        const cx = x + FROG_SIZE / 2;
        const cy = y + FROG_SIZE / 2;

        let ok = true;
        for (const p of positions) {
          const pcx = p.x + FROG_SIZE / 2;
          const pcy = p.y + FROG_SIZE / 2;
          const dx = cx - pcx;
          const dy = cy - pcy;
          if (dx * dx + dy * dy < MIN_DIST * MIN_DIST) {
            ok = false;
            break;
          }
        }
        if (ok) positions.push({ x, y });
      }
      return positions;
    }

    // Create frog objects with idle/hop state
    async function createFrogs(width, height) {
      frogs = [];

      const positions = computeFrogPositions(width, height);
      const tokenIds  = pickRandomTokenIds(positions.length);

      frogs = positions.map((pos, i) => ({
        tokenId: tokenIds[i],
        x: pos.x,
        y: pos.y,
        baseY: pos.y,
        vx: randRange(-10, 10),             // gentle sideways drift
        state: "idle",                      // "idle" | "hopping"
        idleTime: randRange(0.8, 3.0),      // seconds until next hop
        hopTime: 0,                         // time spent in current hop
        hopDuration: randRange(0.35, 0.7),  // hop length in seconds
        hopHeight: randRange(6, 14),        // hop height
        layers: [],
      }));

      await Promise.all(
        frogs.map(async (frog) => {
          try {
            const meta = await fetchMetadata(frog.tokenId);
            frog.layers = await buildLayersFromMetadata(meta);
          } catch (err) {
            // if it fails, frog just won't render
          }
        })
      );
    }

    // ----------------- animation -----------------
    function updateFrogs(dt, width, height) {
      for (const frog of frogs) {
        // sideways drift always on, very slow
        frog.x += frog.vx * dt;
        if (frog.x < -FROG_SIZE * 0.25) {
          frog.x = -FROG_SIZE * 0.25;
          frog.vx *= -1;
        } else if (frog.x > width - FROG_SIZE * 0.75) {
          frog.x = width - FROG_SIZE * 0.75;
          frog.vx *= -1;
        }

        if (frog.state === "idle") {
          frog.idleTime -= dt;
          frog.y = frog.baseY;
          if (frog.idleTime <= 0) {
            // start hop
            frog.state = "hopping";
            frog.hopTime = 0;
            frog.hopDuration = randRange(0.35, 0.7);
            frog.hopHeight = randRange(8, 18);
          }
        } else if (frog.state === "hopping") {
          frog.hopTime += dt;
          const t = Math.min(1, frog.hopTime / frog.hopDuration);

          // simple parabola: 0 -> peak -> 0, scaled to hopHeight (upwards)
          const offset = -4 * frog.hopHeight * t * (1 - t);
          frog.y = frog.baseY + offset;

          if (frog.hopTime >= frog.hopDuration) {
            frog.state = "idle";
            frog.idleTime = randRange(0.8, 3.0);
            frog.y = frog.baseY;
          }
        }
      }
    }

    function drawFrame(time) {
      const dpr = window.devicePixelRatio || 1;
      const width = window.innerWidth;
      const height = window.innerHeight;

      if (!lastTime) lastTime = time;
      const dt = (time - lastTime) / 1000;
      lastTime = time;

      if (canvas.width !== Math.floor(width * dpr) ||
          canvas.height !== Math.floor(height * dpr)) {
        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      ctx.fillStyle = "#7cc1ff";
      ctx.fillRect(0, 0, width, height);
      ctx.imageSmoothingEnabled = false;

      updateFrogs(dt, width, height);

      for (const frog of frogs) {
        if (!frog.layers || frog.layers.length === 0) continue;
        const x = Math.floor(frog.x);
        const y = Math.floor(frog.y);
        for (const layer of frog.layers) {
          if (!layer.img) continue;
          ctx.drawImage(layer.img, x, y, FROG_SIZE, FROG_SIZE);
        }
      }

      animId = requestAnimationFrame(drawFrame);
    }

    async function resetAndStart() {
      const width = window.innerWidth;
      const height = window.innerHeight;

      if (animId) {
        cancelAnimationFrame(animId);
        animId = null;
      }
      lastTime = 0;

      await createFrogs(width, height);
      animId = requestAnimationFrame(drawFrame);
    }

    window.addEventListener("resize", resetAndStart);
    window.addEventListener("load", resetAndStart);
  })();
</script>

  <!-- Main site logic (recent activity, wallet, dashboard, etc.) -->
<script src="/assets/ff-core.js"></script>
<script src="/assets/ff-cards.js"></script>
<script src="/assets/ff-views.js"></script>
<script src="/assets/ff-wallet.js"></script>
</body>
</html>
